%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,8pt,english,openany,oneside,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}


\usepackage{cmap}
\usepackage{fontspec}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}

\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}
\sphinxsetup{hmargin=0.5in, vmargin=1in}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\def\pageautorefname{page}

\setcounter{tocdepth}{2}


        % Use some font with UTF-8 support with XeLaTeX
            \usepackage{fontspec}
            \usepackage{xeCJK}
            \setsansfont[Mapping={}]{Source Code Pro}
            \setromanfont[Mapping={}]{Source Code Pro}
            \setmonofont[Mapping={}]{Source Code Pro}
            \setCJKmainfont{AR PL UMing CN}
            \setCJKsansfont{AR PL UMing CN}
            \definecolor{VerbatimColor}{rgb}{0.95,0.95,0.95}
         \renewcommand*{\DUrole}[2]{ #2 }
\fvset{fontsize=auto}


\title{Kernel Geek}
\date{Aug 04, 2018}
\release{0.2.0.0}
\author{duanwujie}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{抢占}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id1}}\label{\detokenize{003-kernel/ch-003-kernel-preempt::doc}}

\section{非抢占式内核}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id2}}
非抢占式内核是由任务主动放弃CPU的使用权

非抢占式调度法也称作合作型多任务, 各个任务彼此合作共享一个CPU. 异步事件还是由中断服务来处理. 中断服务可以使一个高优先级的任务由挂起状态变为就绪状态.

但中断服务以后控制权还是回到原来被中断了的那个任务, 直到该任务主动放弃CPU的使用权时，那个高优先级的任务才能获得CPU的使用权。非抢占式内核如下图所示:

\noindent\sphinxincludegraphics{{non-preempt-kernel}.png}

非抢占式内核的优点有：
\begin{itemize}
\item {} 
中断响应快(与抢占式内核比较)；

\item {} 
允许使用不可重入函数；

\item {} 
几乎不需要使用信号量保护共享数据。运行的任务占有CPU，不必担心被别的任务抢占。这不是绝对的，在打印机的使用上，仍需要满足互斥条件。

\end{itemize}

非抢占式内核的缺点有：
\begin{itemize}
\item {} 
任务响应时间慢。高优先级的任务已经进入就绪态，但还不能运行，要等到当前运行着的任务释放CPU。

\item {} 
非抢占式内核的任务级响应时间是不确定的，不知道什么时候最高优先级的任务才能拿到CPU的控制权，完全取决于应用程序什么时候释放CPU。

\end{itemize}


\section{抢占式内核}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id3}}
使用抢占式内核可以保证系统响应时间。最高优先级的任务一旦就绪，总能得到CPU的使用权。
当一个运行着的任务使一个比它优先级高的任务进入了就绪态，当前任务的CPU使用权就会被剥夺，或者说被挂起了，那个高优先级的任务立刻得到了CPU的控制权。
如果是中断服务子程序使一个高优先级的任务进入就绪态，
中断完成时，中断了的任务被挂起，优先级高的那个任务开始运行。抢占式内核如下图所示。

\noindent\sphinxincludegraphics{{preempt-kernel}.png}

抢占式内核的优点有:
\begin{itemize}
\item {} 
使用抢占式内核，最高优先级的任务什么时候可以执行，可以得到CPU的使用权是可知的。使用抢占式内核使得任务级响应时间得以最优化。

\end{itemize}

抢占式内核的缺点有:
\begin{itemize}
\item {} 
不能直接使用不可重入型函数。调用不可重入函数时，要满足互斥条件，这点可以使用互斥型信号量来实现。如果调用不可重入型函数时，
低优先级的任务CPU的使用权被高优先级任务剥夺，不可重入型函数中的数据有可能被破坏。

\end{itemize}


\section{用户抢占(User Preemption)}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:user-preemption}}
一般来说, 当进程从系统调用或者从中断(异常)处理程序返回用户空间时会触发主调度器进行用户抢占
\begin{itemize}
\item {} 
从系统调用返回用户空间

\item {} 
从中断(异常)处理程序返回用户空间

\end{itemize}

为了对一个进程需要被调度进行标记, 内核在thread\_info的flag中设置了一个标识来标志进程是否需要重新调度,
即重新调度need\_resched标识TIF\_NEED\_RESCHED,
内核在即将返回用户空间时会检查标识TIF\_NEED\_RESCHED标志进程是否需要重新调度，
如果设置了，就会发生调度, 这被称为用户抢占


\subsection{need\_resched标识}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:need-resched}}
内核如何检查一个进程是否需要被调度呢?

因此内核在thread\_info的flag中设置了一个标识来标志进程是否需要重新调度, 即重新调度need\_resched标识TIF\_NEED\_RESCHED

并提供了一些设置可检测的函数:
\begin{itemize}
\item {} 
set\_tsk\_need\_resched:设置指定进程中的need\_resched标志

\item {} 
clear\_tsk\_need\_resched:清除指定进程中的need\_resched标志

\item {} 
test\_tsk\_need\_resched:检查指定进程need\_resched标志

\end{itemize}

而我们内核中调度时常用的need\_resched()函数检查进程是否需要被重新调度其实就是通过test\_tsk\_need\_resched实现的, 其定义如下所示
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// http://lxr.free\PYGZhy{}electrons.com/source/include/linux/sched.h?v=4.6\PYGZsh{}L3093}
\PYG{k}{static} \PYG{n}{\PYGZus{}\PYGZus{}always\PYGZus{}inline} \PYG{k+kt}{bool} \PYG{n+nf}{need\PYGZus{}resched}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{tif\PYGZus{}need\PYGZus{}resched}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{// http://lxr.free\PYGZhy{}electrons.com/source/include/linux/thread\PYGZus{}info.h?v=4.6\PYGZsh{}L106}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define tif\PYGZus{}need\PYGZus{}resched() test\PYGZus{}thread\PYGZus{}flag(TIF\PYGZus{}NEED\PYGZus{}RESCHED)}
\end{sphinxVerbatim}
\end{quote}


\subsection{用户抢占的发生时机}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id4}}
即什么时候需要重新调度need\_resched,一般来说，用户抢占发生几下情况：
\begin{itemize}
\item {} 
从系统调用返回用户空间；

\item {} 
从中断(异常)处理程序返回用户空间

\end{itemize}

从这里我们可以看到, 用户抢占是发生在用户空间的抢占现象.

更详细的触发条件如下所示, 其实不外乎就是前面所说的两种情况: 从系统调用或者中断返回用户空间
\begin{itemize}
\item {} 
时钟中断处理例程检查当前任务的时间片，当任务的时间片消耗完时，scheduler\_tick()函数就会设置need\_resched标志；

\item {} 
信号量、等到队列、completion等机制唤醒时都是基于waitqueue的，而waitqueue的唤醒函数为default\_wake\_function，其调用try\_to\_wake\_up将被唤醒的任务更改为就绪状态并设置need\_resched标志。

\item {} 
设置用户进程的nice值时，可能会使高优先级的任务进入就绪状态；

\item {} 
改变任务的优先级时，可能会使高优先级的任务进入就绪状态；

\item {} 
新建一个任务时，可能会使高优先级的任务进入就绪状态；

\item {} 
对CPU(SMP)进行负载均衡时，当前任务可能需要放到另外一个CPU上运行

\end{itemize}


\section{内核抢占(Kernel Preemption)}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:kernel-preemption}}
内核态抢占调度发生在下面两者情况：
\begin{itemize}
\item {} 
内核进程运行过程中没有关抢占，有中断产生，在中断返回时，判断出没有关抢占就会调用preempt\_schedule\_irq函数

\item {} 
内核进程运行过程中又产生了更高优先级的进程。

\end{itemize}


\subsection{可抢占的条件}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id5}}
要满足什么条件，kernel才可以抢占一个任务的内核态呢？
\begin{itemize}
\item {} 
没持有锁。锁是用于保护临界区的，不能被抢占。

\item {} 
kernel code可重入(reentrant)。因为kernel是SMP-safe的，所以满足可重入性。

\end{itemize}

如何判断当前上下文(中断处理例程、系统调用、内核线程等)是没持有锁的?
Linux在每个每个任务的thread\_info结构中增加了preempt\_count变量作为preemption的计数器。
这个变量初始为0，当加锁时计数器增一，当解锁时计数器减一。


\subsection{内核态需要抢占的触发条件}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id6}}
内核提供了一个need\_resched标志(这个标志在任务结构thread\_info中)来表明是否需要重新执行调度。


\subsection{何时触发重新调度}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id7}}
set\_tsk\_need\_resched()：设置指定进程中的need\_resched标志

clear\_tsk need\_resched()：清除指定进程中的need\_resched标志

need\_resched()：{\color{red}\bfseries{}检查need\_} resched标志的值;如果被设置就返回真，否则返回假

什么时候需要重新调度：
\begin{itemize}
\item {} 
时钟中断处理例程检查当前任务的时间片，当任务的时间片消耗完时，scheduler\_tick()函数就会设置need\_resched标志；

\item {} 
信号量、等到队列、completion等机制唤醒时都是基于waitqueue的，而waitqueue的唤醒函数为default\_wake\_function，
其调用try\_to\_wake\_up将被唤醒的任务更改为就绪状态并设置need\_resched标志。

\item {} 
设置用户进程的nice值时，可能会使高优先级的任务进入就绪状态；

\item {} 
改变任务的优先级时，可能会使高优先级的任务进入就绪状态；

\item {} 
新建一个任务时，可能会使高优先级的任务进入就绪状态；

\item {} 
对CPU(SMP)进行负载均衡时，当前任务可能需要放到另外一个CPU上运行；

\end{itemize}


\subsection{抢占发生的时机(何时检查可抢占条件)}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id8}}
要满足什么条件，kernel才可以抢占一个任务的内核态呢?
\begin{itemize}
\item {} 
没持有锁。锁是用于保护临界区的，不能被抢占。

\item {} 
Kernel code可重入(reentrant)。因为kernel是SMP-safe的，所以满足可重入性

\end{itemize}

内核抢占发生的时机，一般发生在：
\begin{itemize}
\item {} 
当从中断处理程序正在执行，且返回内核空间之前。当一个中断处理例程退出，在返回到内核态时(kernel-space)。
这是隐式的调用schedule()函数，当前任务没有主动放弃CPU使用权，而是被剥夺了CPU使用权。

\item {} 
当内核代码再一次具有可抢占性的时候，如解锁（spin\_unlock\_bh）及使能软中断(local\_bh\_enable)等,
此时当kernel code从不可抢占状态变为可抢占状态时(preemptible again)。也就是preempt\_count从正整数变为0时。
这也是隐式的调用schedule()函数

\item {} 
如果内核中的任务显式的调用schedule(), 任务主动放弃CPU使用权

\item {} 
如果内核中的任务阻塞(这同样也会导致调用schedule()), 导致需要调用schedule()函数。任务主动放弃CPU使用权数。

\end{itemize}


\subsection{什么时候不允许抢占}
\label{\detokenize{003-kernel/ch-003-kernel-preempt:id9}}
preempt\_count()函数用于获取preempt\_count的值，preemptible()用于判断内核是否可抢占。
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* 在preempt\PYGZus{}count等于0并且没有关中断的情况下 */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define preemptible()   (preempt\PYGZus{}count() == 0 \PYGZam{}\PYGZam{} !irqs\PYGZus{}disabled())}
\end{sphinxVerbatim}
\end{quote}

有几种情况Linux内核不应该被抢占，除此之外，Linux内核在任意一点都可被抢占。这几种情况是：
\begin{itemize}
\item {} 
内核正进行中断处理。在Linux内核中进程不能抢占中断(中断只能被其他中断中止、抢占，进程不能中止、抢占中断)，
在中断例程中不允许进行进程调度。进程调度函数schedule()会对此作出判断，如果是在中断中调用，会打印出错信息。

\item {} 
内核正在进行中断上下文的Bottom Half(中断的下半部)处理。
硬件中断返回前会执行软中断，此时仍然处于中断上下文中。

\item {} 
内核的代码段正持有spinlock自旋锁、writelock/readlock读写锁等锁，处干这些锁的保护状态中。
内核中的这些锁是为了在SMP系统中短时间内保证不同CPU上运行的进程并发执行的正确性。
当持有这些锁时，内核不应该被抢占，否则由于抢占将导致其他CPU长期不能获得锁而死等。

\item {} 
内核正在执行调度程序Scheduler。
抢占的原因就是为了进行新的调度，没有理由将调度程序抢占掉再运行调度程序。

\item {} 
内核正在对每个CPU“私有”的数据结构操作(Per-CPU date structures)。
在SMP中，对于per-CPU数据结构未用spinlocks保护，因为这些数据结构隐含地被保护了
(不同的CPU有不一样的per-CPU数据，其他CPU上运行的进程不会用到另一个CPU的per-CPU数据)。
但是如果允许抢占，但一个进程被抢占后重新调度，有可能调度到其他的CPU上去，
这时定义的Per-CPU变量就会有问题，这时应禁抢占。

\end{itemize}

参考:
\begin{itemize}
\item {} 
\sphinxurl{https://blog.csdn.net/wjf201003050643/article/details/52719141}

\item {} 
\sphinxurl{https://blog.csdn.net/gatieme/article/details/51872618}

\end{itemize}


\chapter{ARM的IPIPE中断处理}
\label{\detokenize{004-ipipe/ch-003-arm-int:armipipe}}\label{\detokenize{004-ipipe/ch-003-arm-int::doc}}
中断和IPIPE整体流程如下图：

\noindent\sphinxincludegraphics{{int-all}.svg}
\begin{enumerate}
\item {} 
左上角图像为中断向量表的跳转过程，详细参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:id2}]{\sphinxcrossref{中断向量表}}}

\item {} 
右上角irq domain中radix-tree的映射过程，主要用于对硬件中断号和irq number进行映射，详细参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:irq-domain}]{\sphinxcrossref{irq domain}}}

\item {} 
右下角为中断控制器驱动(这里是bcm2836)对中断的处理过程,详细参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:irq}]{\sphinxcrossref{外部中断(IRQ)}}}

\item {} 
左下角为ipipe-domain的中断处理流程，详细参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:i-pipe-domain}]{\sphinxcrossref{i-pipe domain}}}

\end{enumerate}


\section{中断初始化}
\label{\detokenize{004-ipipe/ch-003-arm-int:id1}}\begin{enumerate}
\item {} 
什么是中断?

\item {} 
什么是中断源?

\item {} 
什么是中断控制器?

\item {} 
中断向量

\item {} 
中断服务程序(IRS)

\end{enumerate}

中断系统整体初始化流程如下图:

\noindent\sphinxincludegraphics{{int-init}.png}
\begin{enumerate}
\item {} 
中断向量表的初始化,主要在函数 \sphinxcode{\sphinxupquote{early\_trap\_init}} 中完成.(参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:id2}]{\sphinxcrossref{中断向量表}}})

\item {} 
i-pipe domain的初始化,主要在函数 \sphinxcode{\sphinxupquote{\_\_ipipe\_init\_early}} 和 \sphinxcode{\sphinxupquote{\_\_ipipe\_init}} 中完成(参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:i-pipe-domain}]{\sphinxcrossref{i-pipe domain}}} )

\item {} 
irq-domain的初始化,主要在中断控制器驱动中完成(参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:irq-domain}]{\sphinxcrossref{irq domain}}} )

\end{enumerate}


\section{中断向量表}
\label{\detokenize{004-ipipe/ch-003-arm-int:id2}}
\noindent\sphinxincludegraphics{{vector-table}.png}


\subsection{early\_trap\_init}
\label{\detokenize{004-ipipe/ch-003-arm-int:early-trap-init}}\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{//see arch/arm/mm/mmu.c}

\PYG{k}{static} \PYG{k+kt}{void} \PYG{n}{\PYGZus{}\PYGZus{}init} \PYG{n+nf}{devicemaps\PYGZus{}init}\PYG{p}{(}\PYG{k}{const} \PYG{k}{struct} \PYG{n}{machine\PYGZus{}desc} \PYG{o}{*}\PYG{n}{mdesc}\PYG{p}{)}
\PYG{p}{\PYGZob{}}

        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{n}{vectors} \PYG{o}{=} \PYG{n}{early\PYGZus{}alloc}\PYG{p}{(}\PYG{n}{PAGE\PYGZus{}SIZE} \PYG{o}{*} \PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//alloc 2 pages}
        \PYG{n}{early\PYGZus{}trap\PYGZus{}init}\PYG{p}{(}\PYG{n}{vectors}\PYG{p}{)}\PYG{p}{;}\PYG{c+c1}{//copy the interrupt table to vectors}

        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

        \PYG{n}{map}\PYG{p}{.}\PYG{n}{pfn} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}phys\PYGZus{}to\PYGZus{}pfn}\PYG{p}{(}\PYG{n}{virt\PYGZus{}to\PYGZus{}phys}\PYG{p}{(}\PYG{n}{vectors}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{map}\PYG{p}{.}\PYG{n}{virtual} \PYG{o}{=} \PYG{l+m+mh}{0xffff0000}\PYG{p}{;}
        \PYG{n}{map}\PYG{p}{.}\PYG{n}{length} \PYG{o}{=} \PYG{n}{PAGE\PYGZus{}SIZE}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef CONFIG\PYGZus{}KUSER\PYGZus{}HELPERS}
        \PYG{n}{map}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{MT\PYGZus{}HIGH\PYGZus{}VECTORS}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else}
        \PYG{n}{map}\PYG{p}{.}\PYG{n}{type} \PYG{o}{=} \PYG{n}{MT\PYGZus{}LOW\PYGZus{}VECTORS}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{n}{create\PYGZus{}mapping}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{map}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{//map the virtual address 0xffff0000 to the phy page}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{//see arch/arm/kernel/traps.c}
\PYG{k+kt}{void} \PYG{n}{\PYGZus{}\PYGZus{}init} \PYG{n+nf}{early\PYGZus{}trap\PYGZus{}init}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{vectors\PYGZus{}base}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef CONFIG\PYGZus{}CPU\PYGZus{}V7M}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{vectors} \PYG{o}{=} \PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{long}\PYG{p}{)}\PYG{n}{vectors\PYGZus{}base}\PYG{p}{;}


        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

        \PYG{k}{for} \PYG{p}{(}\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{PAGE\PYGZus{}SIZE} \PYG{o}{/} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{u32}\PYG{p}{)}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                \PYG{p}{(}\PYG{p}{(}\PYG{n}{u32} \PYG{o}{*}\PYG{p}{)}\PYG{n}{vectors\PYGZus{}base}\PYG{p}{)}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mh}{0xe7fddef1}\PYG{p}{;}

        \PYG{n}{memcpy}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{p}{)}\PYG{n}{vectors}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}vectors\PYGZus{}start}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}vectors\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{\PYGZus{}\PYGZus{}vectors\PYGZus{}start}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{memcpy}\PYG{p}{(}\PYG{p}{(}\PYG{k+kt}{void} \PYG{o}{*}\PYG{p}{)}\PYG{n}{vectors} \PYG{o}{+} \PYG{l+m+mh}{0x1000}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}stubs\PYGZus{}start}\PYG{p}{,} \PYG{n}{\PYGZus{}\PYGZus{}stubs\PYGZus{}end} \PYG{o}{\PYGZhy{}} \PYG{n}{\PYGZus{}\PYGZus{}stubs\PYGZus{}start}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{else }\PYG{c+cm}{/* ifndef CONFIG\PYGZus{}CPU\PYGZus{}V7M */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
在开启mmu的情况下，先分配2个物理页,将中断向量表复制到分配的物理页，在复制中断向量表之前,先将物理页框填充成未定义指令(0xe7fddef1)
为什么要填充未定义指令? 因为后续的memcpy和kuer helper函数并不能完全的充满这个page，有些缝隙。如果不这么处理，
当极端情况下（程序错误或者HW的issue），CPU可能从这些缝隙中取指执行，从而导致不可知的后果。
如果将这些缝隙填充未定义指令，那么CPU可以捕获这种异常。

\item {} 
调用create\_mapping完成地址0xffff0000到物理地址的映射(即建立对应的页表)

\end{itemize}

为什么内核要将中断向量表拷贝到地址 0xffff0000 %
\begin{footnote}[5]\sphinxAtStartFootnote
该地址是虚拟地址
%
\end{footnote} ?这个是arm cpu的规定：对于ARMv4及其以上的版本，
异常向量表的起始位置由协处理器15（cp15）的控制寄存器(c1)里的V位(bit 13)有关，当V=０时，异常向量表的起始位置在0x00000000，
而当V=１时，异常向量表就起始于0xffff0000位置. 详细参考(ARM1176JZF-S Technical Reference Manual)


\section{软中断(SWI)}
\label{\detokenize{004-ipipe/ch-003-arm-int:swi}}
软中断，主要用于处理系统调用,在 \sphinxcode{\sphinxupquote{arch/arm/kernel/entry-common.S}} 中实现,主要流程如下:

\noindent\sphinxincludegraphics{{vector-swi}.png}


\subsection{vector\_swi}
\label{\detokenize{004-ipipe/ch-003-arm-int:vector-swi}}
当执行vector\_swi的时候，硬件已经做了不少的事情，包括:
\begin{itemize}
\item {} 
将CPSR寄存器保存到SPSR\_svc寄存器中，将返回地址（用户空间执行swi指令的下一条指令）保存在lr\_svc中。
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
         \PYG{c+cm}{/* Store the regster into the current thread\PYGZsq{}s kernel stack */}
         \PYG{n}{sp} \PYG{o}{=} \PYG{n}{sp} \PYG{o}{+} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{strcut} \PYG{n}{pt\PYGZus{}regs}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
                 \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{r}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;} \PYG{c+cm}{/* r0\PYGZhy{}r12 */}
         \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PC}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{sp\PYGZus{}usr}\PYG{p}{;}\PYG{c+cm}{/* r13 */}
         \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PC}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{lr\PYGZus{}usr}\PYG{p}{;}\PYG{c+cm}{/* r14 */}
         \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PC}\PYG{p}{)} \PYG{o}{=} \PYG{n}{lr}\PYG{p}{;}      \PYG{c+cm}{/* r15(pc) */}

         \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PSC}\PYG{p}{)} \PYG{o}{=} \PYG{n}{spsr}\PYG{p}{;}
         \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}OLD\PYGZus{}R0}\PYG{p}{)} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}

         \PYG{c+cm}{/* stmdb: \PYGZlt{}before decrease\PYGZgt{}}
\PYG{c+cm}{          * stmia: \PYGZlt{}after increase\PYGZgt{}}
\PYG{c+cm}{          * stmia   sp, \PYGZob{}r0 \PYGZhy{} r12\PYGZcb{} : Store multiple, increment after.}
\PYG{c+cm}{          * stmdb   r8, \PYGZob{}sp, lr\PYGZcb{}\PYGZca{} : Store multiple, decrease before}
\PYG{c+cm}{          * str     lr, [sp, \PYGZsh{}S\PYGZus{}PC] : Store register[X]}
\PYG{c+cm}{          */}

         \PYG{c+cm}{/* Initialize something */}
         \PYG{n}{zero\PYGZus{}fp}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{enable\PYGZus{}irq}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{ct\PYGZus{}user\PYGZus{}exit}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{get\PYGZus{}thread\PYGZus{}info}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tsk}\PYG{p}{)}\PYG{p}{;}

         \PYG{n}{uaccess\PYGZus{}disable}\PYG{p}{(}\PYG{n}{tbl}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{tbl} \PYG{o}{=} \PYG{n}{sys\PYGZus{}call\PYGZus{}table}\PYG{p}{;}
 \PYG{n+nl}{local\PYGZus{}restart}\PYG{p}{:}
         \PYG{c+cm}{/* xenomai systemcall process */}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{scno}\PYG{o}{!}\PYG{o}{=}\PYG{n}{XENO\PYGZus{}ARM\PYGZus{}SYSCALl}\PYG{p}{)} \PYG{c+cm}{/* not the xenomal system call */}
                 \PYG{k}{goto} \PYG{n}{slow\PYGZus{}path}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}HEAD} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{c+cm}{/* not the realtime thread */}
                 \PYG{k}{goto} \PYG{n}{slow\PYGZus{}path}\PYG{p}{;}
         \PYG{n}{ipipe\PYGZus{}oabi\PYGZus{}save\PYGZus{}sysnr}\PYG{p}{(}\PYG{n}{r10}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{r0} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}fastcall\PYGZus{}hook}\PYG{p}{(}\PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}\PYG{c+cm}{/* regs stored into sp */}
         \PYG{n}{ipipe\PYGZus{}oabi\PYGZus{}restore\PYGZus{}sysnr}\PYG{p}{(}\PYG{n}{r10}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{r0}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{no\PYGZus{}fastcall}\PYG{p}{;}
         \PYG{n}{get\PYGZus{}thread\PYGZus{}info}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tsk}\PYG{p}{)}\PYG{p}{;}

         \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}HEAD}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{fastcall\PYGZus{}exit\PYGZus{}check}\PYG{p}{;}
         \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}root\PYGZus{}sync}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{goto} \PYG{n}{ret\PYGZus{}slow\PYGZus{}syscall}\PYG{p}{;}
 \PYG{n+nl}{fastcall\PYGZus{}exit\PYGZus{}check}\PYG{p}{:}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}MAYDAY} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ret\PYGZus{}to\PYGZus{}user}\PYG{p}{;}
         \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}call\PYGZus{}mayday}\PYG{p}{(}\PYG{p}{)}
         \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ret\PYGZus{}to\PYGZus{}user}
 \PYG{n+nl}{no\PYGZus{}fastcall}\PYG{p}{:}
         \PYG{n}{get\PYGZus{}thread\PYGZus{}info}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tsk}\PYG{p}{)}
         \PYG{n}{r0} \PYG{o}{=} \PYG{n}{XENO\PYGZus{}ARM\PYGZus{}SYSCALl}\PYG{p}{;}
         \PYG{n}{r10} \PYG{o}{=} \PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags}\PYG{p}{;}
 \PYG{n+nl}{slow\PYGZus{}path}\PYG{p}{:}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}NOTIFY}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{pipeline\PYGZus{}syscall}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{scno} \PYG{o}{!}\PYG{o}{=} \PYG{n}{XENO\PYGZus{}ARM\PYGZus{}SYSCALl}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{root\PYGZus{}syscall}\PYG{p}{;}
 \PYG{n+nl}{pipeline\PYGZus{}syscall}\PYG{p}{:}
         \PYG{n}{ipipe\PYGZus{}oabi\PYGZus{}save\PYGZus{}sysnr}\PYG{p}{(}\PYG{n}{r10}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}notify\PYGZus{}syscall}\PYG{p}{(}\PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{ipipe\PYGZus{}oabi\PYGZus{}restore\PYGZus{}sysnr}\PYG{p}{(}\PYG{n}{r10}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{get\PYGZus{}thread\PYGZus{}info}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tsk}\PYG{p}{)}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}HEAD}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ret\PYGZus{}to\PYGZus{}user}\PYG{p}{;}
          \PYG{k}{if}\PYG{p}{(}\PYG{n}{r0}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{ret\PYGZus{}slow\PYGZus{}syscall}\PYG{p}{;}
 \PYG{n+nl}{root\PYGZus{}syscall}\PYG{p}{:}
         \PYG{c+cm}{/* linux system call process */}
         \PYG{n}{r0} \PYG{o}{=} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{;}
         \PYG{n}{r1} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{r2} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{r3} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
         \PYG{c+cm}{/* stmdb        sp!, \PYGZob{}r4, r5\PYGZcb{} : store multiple,decrease before [!: changed] */}
         \PYG{o}{*}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sp}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{;}
         \PYG{o}{*}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sp}\PYG{o}{=}\PYG{n}{r5}\PYG{p}{;}

         \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}WORK}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}sys\PYGZus{}trace}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{scno}\PYG{o}{\PYGZlt{}}\PYG{n}{NR\PYGZus{}syscalls}\PYG{p}{)}
                 \PYG{n}{tbl}\PYG{p}{[}\PYG{n}{scno}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{(}\PYG{n}{r0}\PYG{p}{,}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{n}{r3}\PYG{p}{)}\PYG{p}{;}
                 \PYG{k}{goto} \PYG{n}{ret\PYGZus{}fast\PYGZus{}syscall}\PYG{p}{;}
         \PYG{c+c1}{//other process}
\PYG{c+cm}{/*}
\PYG{c+cm}{         add     r1, sp, \PYGZsh{}S\PYGZus{}OFF}
\PYG{c+cm}{ 2:      cmp     scno, \PYGZsh{}(\PYGZus{}\PYGZus{}ARM\PYGZus{}NR\PYGZus{}BASE \PYGZhy{} \PYGZus{}\PYGZus{}NR\PYGZus{}SYSCALL\PYGZus{}BASE)}
\PYG{c+cm}{         eor     r0, scno, \PYGZsh{}\PYGZus{}\PYGZus{}NR\PYGZus{}SYSCALL\PYGZus{}BASE    @ put OS number back}
\PYG{c+cm}{         bcs     arm\PYGZus{}syscall}
\PYG{c+cm}{         mov     why, \PYGZsh{}0                         @ no longer a real syscall}
\PYG{c+cm}{         b       sys\PYGZus{}ni\PYGZus{}syscall                  @ not private func}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}
\end{quote}

\end{itemize}


\subsubsection{保存调用上下文}
\label{\detokenize{004-ipipe/ch-003-arm-int:id5}}
在保存调用上下文时涉及压栈动作,这里有个问题sp所指向的栈是哪里的内核栈? 在进程进行切换的时候有硬件上下文的切换，
即完成了进程内核栈的切换，换句话说在进入vector\_swi时，进程的内核栈已经准备好了.
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* Store the regster into the current thread\PYGZsq{}s kernel stack */}
\PYG{n}{sp} \PYG{o}{=} \PYG{n}{sp} \PYG{o}{+} \PYG{k}{sizeof}\PYG{p}{(}\PYG{n}{strcut} \PYG{n}{pt\PYGZus{}regs}\PYG{p}{)}\PYG{p}{;}
\PYG{k}{for}\PYG{p}{(}\PYG{n}{i}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{n}{i}\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{l+m+mi}{12}\PYG{p}{;}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{i}\PYG{p}{)} \PYG{o}{=} \PYG{n}{ri}\PYG{p}{;} \PYG{c+cm}{/* r0\PYGZhy{}r12 */}
\PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PC}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{o}{=} \PYG{n}{sp\PYGZus{}usr}\PYG{p}{;}\PYG{c+cm}{/* r13 */}
\PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PC}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{=} \PYG{n}{lr\PYGZus{}usr}\PYG{p}{;}\PYG{c+cm}{/* r14 */}
\PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PC}\PYG{p}{)} \PYG{o}{=} \PYG{n}{lr}\PYG{p}{;}      \PYG{c+cm}{/* r15(pc) */}

\PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}PSC}\PYG{p}{)} \PYG{o}{=} \PYG{n}{spsr}\PYG{p}{;}
\PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{n}{S\PYGZus{}OLD\PYGZus{}R0}\PYG{p}{)} \PYG{o}{=} \PYG{n}{r0}\PYG{p}{;}

\PYG{c+cm}{/* stmdb: \PYGZlt{}before decrease\PYGZgt{}}
\PYG{c+cm}{ * stmia: \PYGZlt{}after increase\PYGZgt{}}
\PYG{c+cm}{ * stmia   sp, \PYGZob{}r0 \PYGZhy{} r12\PYGZcb{} : Store multiple, increment after.}
\PYG{c+cm}{ * stmdb   r8, \PYGZob{}sp, lr\PYGZcb{}\PYGZca{} : Store multiple, decrease before}
\PYG{c+cm}{ * str     lr, [sp, \PYGZsh{}S\PYGZus{}PC] : Store register[X]}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}
\end{quote}

\noindent\sphinxincludegraphics{{kernel-stack}.png}

为何r0被两次压栈？一个是r0，另外一个是old r0。其实在系统调用过程中，r0有两个角色，一个是传递参数，另外一个是返回值。刚进入系统调用现场的时候，

对于ARM，当然是寄存器了， 特别是返回结果，保存在了r0中。对于ARM，r0～r7是各种cpu mode都相同的，用于传递参数还是很方便的。因此，进入系统调用的时候，在内核栈上保存了发生系统调用现场的所有寄存器，一方面保存了hardware context，另外一方面，也就是获取了系统调用的参数。返回的时候，将返回值放到r0就OK了。
根据上面的描述，r0有两个作用，传递参数，返回结果。当把系统调用的结果放到r0的时候，通过r0传递的参数值就被覆盖了。
本来，这也没有什么，但是有些场合是需要需要这两个值的：
1. ptrace （和debugger相关，这里就不再详细描述了）
2. system call restart （和signal相关，这里就不再详细描述了）
正因为如此，硬件上下文的寄存器中r0有两份，ARM\_r0是传递的参数，并复制一份到ARM\_ORIG\_r0，当系统调用返回的时候，ARM\_r0是系统调用的返回值。


\subsubsection{一些初始化操作}
\label{\detokenize{004-ipipe/ch-003-arm-int:id6}}\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{ENTRY}\PYG{p}{(}\PYG{n+no}{vector\PYGZus{}swi}\PYG{p}{)}
        \PYG{n+na}{...}
        \PYG{n+nf}{zero\PYGZus{}fp}
        \PYG{n+nf}{alignment\PYGZus{}trap} \PYG{n+no}{r10}\PYG{p}{,} \PYG{n+no}{ip}\PYG{p}{,} \PYG{n+no}{\PYGZus{}\PYGZus{}cr\PYGZus{}alignment}
        \PYG{n+nf}{enable\PYGZus{}irq}
        \PYG{n+nf}{ct\PYGZus{}user\PYGZus{}exit} \PYG{c+c1}{@do nothing if CONFIG\PYGZus{}CONTEXT\PYGZus{}TRACKING not defined}
        \PYG{n+nf}{get\PYGZus{}thread\PYGZus{}info} \PYG{n+no}{tsk}
        \PYG{n+na}{...}
\PYG{n+nf}{ENDPROC}\PYG{p}{(}\PYG{n+no}{vector\PYGZus{}swi}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

zero\_fp用来清除frame pointer，在debugger做栈的回溯的时候，当fp等于0的时候也就意味着到了最外层函数。
对于kernel而言，来到这里，函数的调用跟踪就结束了，我们不可能一直回溯到用户空间的函数调用。

enalbe\_irq开启irq中断，这里为什么要开启irq中断呢？如果在处理系统调用的过程中，来了irq中断怎么办?

我们考虑这么一个情况，假设只有一个处理器，其cpu上运行了一个线程，该线程不停的触发软中断(swi),
此时网卡有数据到来，并且触发了irq中断。那么内核怎么办?

内核可能的处理方式为:
\begin{enumerate}
\item {} 
在软中断的整个过程中，全程禁用irq直到软中断处理完成。

\item {} 
在软中断的整个过程中，全程开启irq中断。

\item {} 
在紧急时刻关闭irq,在非紧急时刻开启irq中断。

\end{enumerate}

对于方式1，假设我们正在浏览网页,但因为线程触发了软中断,而内核全程禁用了irq，倒霉的是该软中断的处理时间很长，长到难以忍受，由于内核
没能及时处理网卡过来的irq中断，此时用户会感觉浏览网页非常缓慢，甚至一直没有响应，显然这种情况是不能接受的，因此这种处理方式也不能接受!

对于方式2，同样的我们正在浏览网页或者下载视频，而如果内核在处理软中断的过程中全程开启了irq中断，倒霉的是网卡不停的触发irq中断，导致软中断
一直被打断，此时用户线程一直的软中断请求一直的不到满足，显然这种情况也是不能接受,而且有一个致命的问题，如果用户线程的软中断请求上下文没有保存
就触发了irq中断，此时将造成软中断请求上下文丢失。此时如果irq中断处理完成后，继续处理软中断，将会是未知的行为。

好了前面的两种方式都是不可选的，也就只剩下了方式3了，在紧急时刻关闭irq，在非紧急时刻开启irq中断,从vector\_swi处理代码中，我们可以看出开启irq中断
是在保存完了调用上下文后开启的，这样的好处是当irq中断发生时，可以先去处理irq中断，等irq中断处理完成时，再继续软中断的处理，显然这样处理提高
中断处理的吞吐量。这也就是为什么Linux要讲中断处理分成上半部分和下半部的原因。


\subsubsection{如何获取系统调用号?}
\label{\detokenize{004-ipipe/ch-003-arm-int:id7}}
系统调用有两种规范，一种是老的OABI(系统调用号来自swi指令中)，另外一种是ARM ABI，也就是EABI（系统调用号来自r7）。
如果想要兼容旧的OABI，那么我们需要定义OABI\_COMPAT，这会带来一点系统调用的开销，同时让内核变大一点，
对应的好处是使用旧的OABI规格的用户程序也可以运行在内核之上。
当然，如果我们确定用户空间只是服从EABI规范，那么可以考虑不定义 \sphinxcode{\sphinxupquote{CONFIG\_OABI\_COMPAT}} 。我们没有定义 \sphinxcode{\sphinxupquote{CONFIG\_OABI\_COMPAT}}

对于EABI系统调用规范，系统调用号直接在r7寄存器中,不需要特别的代码。其他规范，只是取系统调用号的方式不同，这里不做讨论!

在应用层中使用ARM EABI %
\begin{footnote}[2]\sphinxAtStartFootnote
EABI:其中约定了在使用软中断时，参数传递方式和系统调用号的传递方式;
%
\end{footnote} 规范来进行系统调用．参考 \sphinxcode{\sphinxupquote{lib/cobalt/arch/arm/include/asm/xenomai/syscall.h}},xenomai使用一个唯一的系统
调用号和多个功能号来处理所有cobalt内核提供的系统调用.伪代码如下:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{r0} \PYG{o}{=} \PYG{n}{syscode}\PYG{p}{;}
\PYG{n}{r7} \PYG{o}{=} \PYG{n}{syscall\PYGZus{}number}\PYG{p}{;}
\PYG{p}{[}\PYG{n}{r1}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{n}{r5}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{arg1} \PYG{p}{.}\PYG{p}{.}\PYG{p}{.} \PYG{n}{arg5}\PYG{p}{]}\PYG{p}{;}
\PYG{n}{swi} \PYG{l+m+mi}{0}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
寄存器r0:存放的是功能号，这里的的功能号就是内核中cobalt\_syscalls数组的下标，用于索引对应的系统调用，详细参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:id12}]{\sphinxcrossref{系统调用}}}

\item {} 
寄存器r7:存放的是系统调用号，xenomai使用0x000F0042.

\end{itemize}

相关代码如下:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nf}{ENTRY}\PYG{p}{(}\PYG{n+no}{vector\PYGZus{}swi}\PYG{p}{)}
        \PYG{n+na}{...}
        \PYG{c+cm}{/*}
\PYG{c+cm}{         * Get the system call number.}
\PYG{c+cm}{         */}
        \PYG{n+na}{...}
\PYG{n+nf}{ENDPROC}\PYG{p}{(}\PYG{n+no}{vector\PYGZus{}swi}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\subsubsection{IPIPE软中断处理}
\label{\detokenize{004-ipipe/ch-003-arm-int:ipipe}}
IPIPI软中断处理流程如下(以下是C的伪代码):
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nl}{local\PYGZus{}restart}\PYG{p}{:}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{scno} \PYG{o}{!}\PYG{o}{=} \PYG{n}{XENO\PYGZus{}ARM\PYGZus{}SYSCALL}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{slow\PYGZus{}path}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}HEAD} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+cm}{/* task was normal thread */}
                \PYG{k}{goto} \PYG{n}{slow\PYGZus{}path}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{ipipe\PYGZus{}fastcall\PYGZus{}hook}\PYG{p}{(}\PYG{n}{regs}\PYG{p}{)}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{)} \PYG{c+cm}{/* task was realtime thread */}
                \PYG{k}{goto} \PYG{n}{no\PYGZus{}fastcall}\PYG{p}{;}
        \PYG{n}{get\PYGZus{}thread\PYGZus{}info}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{tsk}\PYG{p}{)}\PYG{p}{;}
        \PYG{c+cm}{/* Notice:The ipipe\PYGZus{}fastcall\PYGZus{}hook maybe clear the \PYGZus{}TIP\PYGZus{}HEAD flag */}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}HEAD}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{fastcall\PYGZus{}exit\PYGZus{}check}\PYG{p}{;}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}root\PYGZus{}sync}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{goto} \PYG{n}{ret\PYGZus{}slow\PYGZus{}syscall}\PYG{p}{;}
\PYG{n+nl}{fastcall\PYGZus{}exit\PYGZus{}check}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}MAYDAY} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ret\PYGZus{}to\PYGZus{}user}\PYG{p}{;}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}call\PYGZus{}mayday}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ret\PYGZus{}to\PYGZus{}user}\PYG{p}{;}
\PYG{n+nl}{no\PYGZus{}fastcall}\PYG{p}{:}
\PYG{n+nl}{slow\PYGZus{}path}\PYG{p}{:}
        \PYG{c+cm}{/* Notify the head domain about kernel event */}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}NOTIFY}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{pipeline\PYGZus{}syscall}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{scno}\PYG{o}{!}\PYG{o}{=}\PYG{n}{XENO\PYGZus{}ARM\PYGZus{}SYSCALL}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{root\PYGZus{}syscall}\PYG{p}{;}
\PYG{n+nl}{pipeline\PYGZus{}syscall}\PYG{p}{:}
        \PYG{c+cm}{/* When to call this ? */}
        \PYG{n}{r0} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}notify\PYGZus{}syscall}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ipipe\PYGZus{}flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIP\PYGZus{}HEAD}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ret\PYGZus{}to\PYGZus{}user}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{r0}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n+nl}{ret\PYGZus{}slow\PYGZus{}syscall}\PYG{p}{:}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\item {} 
判断是否是xenomai的系统调用，如果是并且线程的ipipe\_flags设置了TIP\_HEAD %
\begin{footnote}[1]\sphinxAtStartFootnote
TIP\_HEAD:线程标志，表示线程运行在ipipe head域.
%
\end{footnote} 标志，说明该swi是处于ipipe head域的实时线程产生的.
实时线程的软中断让 \sphinxcode{\sphinxupquote{ipipe\_fastcall\_hook()}} 进行处理.

\item {} 
\sphinxcode{\sphinxupquote{ipipe\_fastcall\_hook}} 函数是使用gcc weak属性定义的，被xenomai重写了，如果没有xenomai，则让Linux对swi正常进行处理(参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:linux}]{\sphinxcrossref{linux软中断处理}}} )

\end{enumerate}


\subsubsection{linux软中断处理}
\label{\detokenize{004-ipipe/ch-003-arm-int:linux}}\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nl}{root\PYGZus{}syscall}\PYG{p}{:}
         \PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define \PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}WORK (\PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}TRACE \textbar{} \PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}AUDIT \textbar{} \PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}TRACEPOINT \textbar{} \PYGZus{}TIF\PYGZus{}SECCOMP)}
         \PYG{c+cm}{/* ldmia sp,\PYGZob{}r0\PYGZhy{}r3\PYGZcb{}: load multiple,increase after */}
         \PYG{n}{r0} \PYG{o}{=} \PYG{o}{*}\PYG{n}{sp}\PYG{p}{;}
         \PYG{n}{r1} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{r2} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
         \PYG{n}{r3} \PYG{o}{=} \PYG{o}{*}\PYG{p}{(}\PYG{n}{sp}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}

         \PYG{c+cm}{/* stmdb        sp!, \PYGZob{}r4, r5\PYGZcb{} : store multiple,decrease before [!: changed] */}
         \PYG{o}{*}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sp}\PYG{o}{=}\PYG{n}{r4}\PYG{p}{;}
         \PYG{o}{*}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{sp}\PYG{o}{=}\PYG{n}{r5}\PYG{p}{;}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}WORK}\PYG{p}{)}
                 \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}sys\PYGZus{}trace}
         \PYG{k}{if}\PYG{p}{(}\PYG{n}{scno}\PYG{o}{\PYGZlt{}}\PYG{n}{NR\PYGZus{}syscalls}\PYG{p}{)}
                 \PYG{n}{tbl}\PYG{p}{[}\PYG{n}{scno}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{(}\PYG{n}{r0}\PYG{p}{,}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{n}{r3}\PYG{p}{)}\PYG{p}{;}
                 \PYG{k}{goto} \PYG{n}{ret\PYGZus{}fast\PYGZus{}syscall}\PYG{p}{;}
         \PYG{c+c1}{//other process}
\PYG{c+cm}{/*}
\PYG{c+cm}{         add     r1, sp, \PYGZsh{}S\PYGZus{}OFF}
\PYG{c+cm}{ 2:      cmp     scno, \PYGZsh{}(\PYGZus{}\PYGZus{}ARM\PYGZus{}NR\PYGZus{}BASE \PYGZhy{} \PYGZus{}\PYGZus{}NR\PYGZus{}SYSCALL\PYGZus{}BASE)}
\PYG{c+cm}{         eor     r0, scno, \PYGZsh{}\PYGZus{}\PYGZus{}NR\PYGZus{}SYSCALL\PYGZus{}BASE    @ put OS number back}
\PYG{c+cm}{         bcs     arm\PYGZus{}syscall}
\PYG{c+cm}{         mov     why, \PYGZsh{}0                         @ no longer a real syscall}
\PYG{c+cm}{         b       sys\PYGZus{}ni\PYGZus{}syscall                  @ not private func}
\PYG{c+cm}{ */}
\end{sphinxVerbatim}
\end{quote}

对于ARM处理器，标准过程调用约定使用r0～r3来传递参数，其余的参数压入栈中


\subsubsection{返回用户空间(ret\_fast\_syscall)}
\label{\detokenize{004-ipipe/ch-003-arm-int:ret-fast-syscall}}
See arch/arm/kernel/entry-common.S
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* see arm/include/asm/thread\PYGZus{}info.h */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define \PYGZus{}TIF\PYGZus{}WORK\PYGZus{}MASK (\PYGZus{}TIF\PYGZus{}NEED\PYGZus{}RESCHED \textbar{} \PYGZus{}TIF\PYGZus{}SIGPENDING \textbar{} \PYGZus{}TIF\PYGZus{}NOTIFY\PYGZus{}RESUME \textbar{} \PYGZus{}TIF\PYGZus{}UPROBE)}


\PYG{n+nl}{ret\PYGZus{}fast\PYGZus{}syscall}\PYG{p}{:}
        \PYG{n}{disable\PYGZus{}irq\PYGZus{}notrace}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{c+cm}{/* disable the irq interrupt */}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{p}{(}\PYG{n}{\PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}WORK}\PYG{o}{\textbar{}}\PYG{n}{\PYGZus{}TIF\PYGZus{}WORK\PYGZus{}MASK}\PYG{p}{)}\PYG{p}{)} \PYG{c+cm}{/* check the TIF\PYGZus{}NEED\PYGZus{}RESCHED flags */}
                \PYG{k}{goto} \PYG{n}{fast\PYGZus{}work\PYGZus{}pending}\PYG{p}{;}
        \PYG{n}{arch\PYGZus{}ret\PYGZus{}to\PYGZus{}user}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{,}\PYG{n}{lr}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{restore\PYGZus{}user\PYGZus{}regs}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{SOFF}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nl}{fast\PYGZus{}work\PYGZus{}pending}\PYG{p}{:}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{tsk0}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}TIF\PYGZus{}SYSCALL\PYGZus{}WORK}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{\PYGZus{}\PYGZus{}sys\PYGZus{}trace\PYGZus{}return\PYGZus{}nosave}
\PYG{n+nl}{slow\PYGZus{}work\PYGZus{}pending}\PYG{p}{:}
        \PYG{c+cm}{/* r0 = sp,r1=tsk\PYGZhy{}\PYGZgt{}flags,syscall= why */}
        \PYG{n}{r0} \PYG{o}{=} \PYG{n}{do\PYGZus{}work\PYGZus{}pending}\PYG{p}{(}\PYG{n}{regs}\PYG{p}{,}\PYG{n}{tsk}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags}\PYG{p}{,}\PYG{n}{why}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if}\PYG{p}{(}\PYG{n}{r0} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{no\PYGZus{}work\PYGZus{}pending}\PYG{p}{;}
        \PYG{k}{goto} \PYG{n}{local\PYGZus{}restart}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

这里面最著名的flag就是\_TIF\_NEED\_RESCHED，有了这个flag，说明有调度需求。由此可知在系统调用返回用户空间的时候上有一个调度点。其他的flag和我们这里的场景无关，这里就不描述了，总而言之，如果需要有其他额外的事情要处理，我们需要跳转到fast\_work\_pending ，否则调用restore\_user\_regs返回用户空间现场

恢复用户空间的代码:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+na}{.macro}  \PYG{n+no}{restore\PYGZus{}user\PYGZus{}regs}\PYG{p}{,} \PYG{n+no}{fast} \PYG{p}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n+no}{offset} \PYG{p}{=} \PYG{l+m+mi}{0}
        \PYG{n+nf}{uaccess\PYGZus{}enable} \PYG{n+no}{r1}\PYG{p}{,} \PYG{n+no}{isb}\PYG{p}{=}\PYG{l+m+mi}{0}
        \PYG{c+c1}{@ ARM mode restore}
        \PYG{n+nf}{mov}     \PYG{n+no}{r2}\PYG{p}{,} \PYG{n+no}{sp}
        \PYG{n+nf}{ldr}     \PYG{n+no}{r1}\PYG{p}{,} \PYG{p}{[}\PYG{n+no}{r2}\PYG{p}{,} \PYG{p}{\PYGZsh{}\PYGZbs{}}\PYG{n+no}{offset} \PYG{p}{+} \PYG{n+no}{S\PYGZus{}PSR}\PYG{p}{]}      \PYG{c+c1}{@ get calling cpsr}
        \PYG{n+nf}{ldr}     \PYG{n+no}{lr}\PYG{p}{,} \PYG{p}{[}\PYG{n+no}{r2}\PYG{p}{,} \PYG{p}{\PYGZsh{}\PYGZbs{}}\PYG{n+no}{offset} \PYG{p}{+} \PYG{n+no}{S\PYGZus{}PC}\PYG{p}{]!}      \PYG{c+c1}{@ get pc}
        \PYG{n+nf}{msr}     \PYG{n+no}{spsr\PYGZus{}cxsf}\PYG{p}{,} \PYG{n+no}{r1}                   \PYG{c+c1}{@ save in spsr\PYGZus{}svc}
        \PYG{n+nf}{ldmdb}   \PYG{n+no}{r2}\PYG{p}{,} \PYG{p}{\PYGZob{}}\PYG{n+no}{r1} \PYG{p}{\PYGZhy{}} \PYG{n+no}{lr}\PYG{p}{\PYGZcb{}\PYGZca{}}                  \PYG{c+c1}{@ get calling r1 \PYGZhy{} lr}
        \PYG{n+nf}{mov}     \PYG{n+no}{r0}\PYG{p}{,} \PYG{n+no}{r0}                          \PYG{c+c1}{@ ARMv5T and earlier require a nop}
        \PYG{n+nf}{add}     \PYG{n+no}{sp}\PYG{p}{,} \PYG{n+no}{sp}\PYG{p}{,} \PYG{p}{\PYGZsh{}\PYGZbs{}}\PYG{n+no}{offset} \PYG{p}{+} \PYG{n+no}{PT\PYGZus{}REGS\PYGZus{}SIZE}
        \PYG{n+nf}{movs}    \PYG{n+no}{pc}\PYG{p}{,} \PYG{n+no}{lr}                          \PYG{c+c1}{@ return \PYGZam{} move spsr\PYGZus{}svc into cpsr}
\PYG{n+na}{.endm}
\end{sphinxVerbatim}
\end{quote}

整个代码比较简单，就是用进入系统调用时候压入内核栈的值来进行用户现场的恢复，其中一个细节是内核栈的操作，
在调用 \sphinxcode{\sphinxupquote{movs    pc, lr}} 返回用户空间现场之前, \sphinxcode{\sphinxupquote{add    sp, sp, \#\textbackslash{}offset + S\_FRAME\_SIZE}}
指令确保用户栈上是空的。此外，我们需要考虑返回用户空间时候的r0设置问题，毕竟它承载了本次系统调用的返回值，这时候的r0有两种情况：
\begin{enumerate}
\item {} 
在没有pending work的情况下（fast等于1），r0保存了sys\_xxx函数的返回值

\item {} 
在有pending work的情况下（fast等于0），struct pt\_regs（返回用户空间的现场）中的r0保存了sys\_xxx函数的返回值

\end{enumerate}

restore\_user\_regs还有一个参数叫做offset，我们知道，在进入系统调用的时候，我们把参数5和参数6压入栈上，
因此产生了到pt\_regs8个字节的偏移，这里需要补偿回来。


\subsection{系统调用}
\label{\detokenize{004-ipipe/ch-003-arm-int:id12}}
cobalt内核的系统调用在 \sphinxcode{\sphinxupquote{kernel/cobalt/posix/*.c}} 实现,使用宏 \sphinxcode{\sphinxupquote{COBALT\_SYSCALL}} 进行定义,该宏在 \sphinxcode{\sphinxupquote{kernel/cobalt/posix/syscall.h}} 文件中定义:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define COBALT\PYGZus{}SYSCALL(\PYGZus{}\PYGZus{}name, \PYGZus{}\PYGZus{}mode, \PYGZus{}\PYGZus{}args)      \PYGZbs{}}
\PYG{c+cp}{        long CoBaLt\PYGZus{} \PYGZsh{}\PYGZsh{} \PYGZus{}\PYGZus{}name \PYGZus{}\PYGZus{}args}
\end{sphinxVerbatim}
\end{quote}

从宏定义来看所有系统调用的返回参数是long型，并且系统名字命名方式为: CoBaLt\_XXXXX，比如:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{COBALT\PYGZus{}SYSCALL}\PYG{p}{(}\PYG{n}{fcntl}\PYG{p}{,} \PYG{n}{current}\PYG{p}{,} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{fd}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{cmd}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{rtdm\PYGZus{}fd\PYGZus{}fcntl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,} \PYG{n}{cmd}\PYG{p}{,} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* After preprocess : */}
\PYG{k+kt}{long} \PYG{n}{CoBaLt\PYGZus{}fcntl} \PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{fd}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{cmd} \PYG{k+kt}{int} \PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{return} \PYG{n}{rtdm\PYGZus{}fd\PYGZus{}fcntl}\PYG{p}{(}\PYG{n}{fd}\PYG{p}{,}\PYG{n}{cmd}\PYG{p}{,}\PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

系统调用功能号在 \sphinxcode{\sphinxupquote{include/cobalt/uapi/syscall.h}} 中定义
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}bind                              0}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}create                     1}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}getpid                     2}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}setmode            3}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}setname            4}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}join                       5}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}kill                       6}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}setsvector\PYGZus{}swi}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\end{sphinxVerbatim}
\end{quote}

在 \sphinxcode{\sphinxupquote{kernel/cobalt/posix/syscall.c}} 定义了一个数组 \sphinxcode{\sphinxupquote{cobalt\_syscalls}} 数组元素都是系统调用指针，
数组下标则是系统调用的功能号(syscode)，其中 \sphinxcode{\sphinxupquote{syscall\_entries.h}} 是使用
脚本动态生成的！该文件定义了宏 \sphinxcode{\sphinxupquote{\_\_COBALT\_CALL\_ENTRIES}} 负责初始化 \sphinxcode{\sphinxupquote{cobalt\_syscalls}} 数组，
而 \sphinxcode{\sphinxupquote{\_\_COBALT\_CALL\_ENTRY}} 宏则是初始化 \sphinxcode{\sphinxupquote{cobalt\_syscalls}} 数组的一个元素,使用gcc扩展对一个元素进行赋值类似于
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k}{const} \PYG{n}{cobalt\PYGZus{}syshand} \PYG{n}{cobalt\PYGZus{}syscalls}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{p}{[}\PYG{n}{sc\PYGZus{}cobalt\PYGZus{}bind}\PYG{p}{]} \PYG{o}{=} \PYG{n}{CoBaLt\PYGZus{}bind}\PYG{p}{,}
    \PYG{p}{[}\PYG{n}{sc\PYGZus{}cobalt\PYGZus{}thread\PYGZus{}create}\PYG{p}{]} \PYG{o}{=} \PYG{n}{Coalt\PYGZus{}thread\PYGZus{}create}\PYG{p}{,}
    \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}


\PYG{c+cm}{/* initialise the cobalt\PYGZus{}syscalls */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define \PYGZus{}\PYGZus{}COBALT\PYGZus{}CALL\PYGZus{}ENTRY(\PYGZus{}\PYGZus{}name)                         \PYGZbs{}}
\PYG{c+cp}{    [sc\PYGZus{}cobalt\PYGZus{} \PYGZsh{}\PYGZsh{} \PYGZus{}\PYGZus{}name] = \PYGZus{}\PYGZus{}syshand\PYGZus{}\PYGZus{}(\PYGZus{}\PYGZus{}name),           \PYGZbs{}}
\PYG{c+cp}{    \PYGZus{}\PYGZus{}COBALT\PYGZus{}CALL32\PYGZus{}ENTRY(\PYGZus{}\PYGZus{}name, \PYGZus{}\PYGZus{}syshand\PYGZus{}\PYGZus{}(\PYGZus{}\PYGZus{}name))}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}syscall\PYGZus{}entries.h\PYGZdq{}}

\PYG{k}{static} \PYG{k}{const} \PYG{n}{cobalt\PYGZus{}syshand} \PYG{n}{cobalt\PYGZus{}syscalls}\PYG{p}{[}\PYG{p}{]} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{n}{\PYGZus{}\PYGZus{}COBALT\PYGZus{}CALL\PYGZus{}NI}
    \PYG{n}{\PYGZus{}\PYGZus{}COBALT\PYGZus{}CALL\PYGZus{}ENTRIES}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef CONFIG\PYGZus{}XENO\PYGZus{}ARCH\PYGZus{}SYS3264}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}asm/xenomai/syscall32\PYGZhy{}table.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

其整体调用流程如下图：

\noindent\sphinxincludegraphics{{system-call}.png}


\subsection{各种系统调用的处理}
\label{\detokenize{004-ipipe/ch-003-arm-int:id13}}
在xenomai双内核中系统调用有4种情况:
\begin{itemize}
\item {} 
实时线程调用xenomai系统调用\textendash{}\textgreater{}ipipe\_fastcall\_hook

\item {} 
实时线程调用普通系统调用

\item {} 
普通线程调用xenomai系统调用,

\item {} 
普通线程调用普通系统调用，直接调用系统调用就好

\end{itemize}

对于实时线程其 tsk-\textgreater{}ipipe\_flags设置了\_TIP\_HEAD标志，普通线程调用xenomai系统调用thread\_create时，设置TIP\_NOTIFY标志


\section{外部中断(IRQ)}
\label{\detokenize{004-ipipe/ch-003-arm-int:irq}}
外部中断在 \sphinxcode{\sphinxupquote{arm/kernel/entry-armv.S}} 中实现,其中vector\_irq，主要完成模式切换(即切换到svc模式)和中断的分发;

当中断发生时，处于CPU处于usr模式下，则调用 \sphinxcode{\sphinxupquote{\_\_irq\_usr}} ，如CPU处于svc模式下，则调用 \sphinxcode{\sphinxupquote{\_\_irq\_svc}}


\subsection{用户态IRQ}
\label{\detokenize{004-ipipe/ch-003-arm-int:id14}}
总体流程如下:

\noindent\sphinxincludegraphics{{irq-usr}.png}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nl}{\PYGZus{}irq\PYGZus{}usr:}
       \PYG{c+cm}{/* keep the usr register */}
       \PYG{n+nf}{usr\PYGZus{}entry}
       \PYG{n+nf}{kuser\PYGZus{}cmpxchg\PYGZus{}check}
       \PYG{n+nf}{irq\PYGZus{}handler}
       \PYG{n+nf}{bne}     \PYG{n+no}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ret\PYGZus{}to\PYGZus{}user\PYGZus{}irqs\PYGZus{}disabled}
       \PYG{n+nf}{get\PYGZus{}thread\PYGZus{}info} \PYG{n+no}{tsk}
       \PYG{n+nf}{mov}     \PYG{n+no}{why}\PYG{p}{,} \PYG{p}{\PYGZsh{}}\PYG{l+m+mi}{0}
       \PYG{n+nf}{b}       \PYG{n+no}{ret\PYGZus{}to\PYGZus{}user\PYGZus{}from\PYGZus{}irq}
       \PYG{n+na}{....}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
user\_entry:保存用户寄存器

\item {} 
irq\_handler:分别有两种情况,参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:irq-handler}]{\sphinxcrossref{irq\_handler}}}

\item {} 
\_\_ipipe\_grab\_ipi: 用于处理IPI,参见核间中断处理 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:ipipe-grab-ipi}]{\sphinxcrossref{\_\_ipipe\_grab\_ipi()}}}

\item {} 
\_\_ipipe\_grab\_irq: 用于处理IO中断,参见IO中断处理 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:ipipe-grab-irq}]{\sphinxcrossref{\_\_ipipe\_grab\_irq()}}}

\end{itemize}


\subsubsection{irq\_handler}
\label{\detokenize{004-ipipe/ch-003-arm-int:irq-handler}}
irq\_handler的处理有两种配置。一种是配置了CONFIG\_MULTI\_IRQ\_HANDLER。这种情况下，linux kernel允许run time设定irq handler。
如果我们需要一个linux kernel image支持多个平台，这是就需要配置这个选项。另外一种是传统的linux的做法，
irq\_handler实际上就是arch\_irq\_handler\_default，具体代码如下:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
/*
 * Interrupt handling.
 */
        .macro  irq\PYGZus{}handler
\PYGZsh{}ifdef CONFIG\PYGZus{}MULTI\PYGZus{}IRQ\PYGZus{}HANDLER
        ldr     r1, =handle\PYGZus{}arch\PYGZus{}irq
        mov     r0, sp
        badr    lr, 9997f @Set the return address
        ldr     pc, [r1]
\PYGZsh{}else
        arch\PYGZus{}irq\PYGZus{}handler\PYGZus{}default
\PYGZsh{}endif
9997:
\PYGZsh{}ifdef CONFIG\PYGZus{}IPIPE
        bl      \PYGZus{}\PYGZus{}ipipe\PYGZus{}check\PYGZus{}root\PYGZus{}interruptible
        cmp     r0, \PYGZsh{}1
\PYGZsh{}endif /* CONFIG\PYGZus{}IPIPE */
        .endm
\end{sphinxVerbatim}
\end{quote}

对于配置了 \sphinxcode{\sphinxupquote{CONFIG\_MULTI\_IRQ\_HANDLER}} 调用直接调用 handle\_arch\_irq机可，当然,要先准备好参数传递和返回地址设定。调用形式如下:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{handle\PYGZus{}arch\PYGZus{}irq}\PYG{p}{(}\PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}

对于rpi3是在注册中断控制器驱动时，初始化的 handle\_arch\_irq函数指针：
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{int} \PYG{n}{\PYGZus{}\PYGZus{}init} \PYG{n+nf}{bcm2836\PYGZus{}arm\PYGZus{}irqchip\PYGZus{}l1\PYGZus{}intc\PYGZus{}of\PYGZus{}init}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{device\PYGZus{}node} \PYG{o}{*}\PYG{n}{node}\PYG{p}{,}
                                                      \PYG{k}{struct} \PYG{n}{device\PYGZus{}node} \PYG{o}{*}\PYG{n}{parent}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{n}{intc}\PYG{p}{.}\PYG{n}{base} \PYG{o}{=} \PYG{n}{of\PYGZus{}iomap}\PYG{p}{(}\PYG{n}{node}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}

        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{n}{set\PYGZus{}handle\PYGZus{}irq}\PYG{p}{(}\PYG{n}{bcm2836\PYGZus{}arm\PYGZus{}irqchip\PYGZus{}handle\PYGZus{}irq}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}


\subsubsection{arch\_irq\_handler\_default}
\label{\detokenize{004-ipipe/ch-003-arm-int:arch-irq-handler-default}}
See arch/arm/include/asm/entry-macro-multi.S

对于没有配置CONFIG\_MULTI\_IRQ\_HANDLER的情况来说，要稍显得复杂，代码如下:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        \PYG{n+na}{.macro}  \PYG{n+no}{arch\PYGZus{}irq\PYGZus{}handler\PYGZus{}default}
        \PYG{n+nf}{get\PYGZus{}irqnr\PYGZus{}preamble} \PYG{n+no}{r6}\PYG{p}{,} \PYG{n+no}{lr}

\PYG{n+nl}{1:}      \PYG{n+nf}{get\PYGZus{}irqnr\PYGZus{}and\PYGZus{}base} \PYG{n+no}{r0}\PYG{p}{,} \PYG{n+no}{r2}\PYG{p}{,} \PYG{n+no}{r6}\PYG{p}{,} \PYG{n+no}{lr}
        \PYG{n+nf}{movne}   \PYG{n+no}{r1}\PYG{p}{,} \PYG{n+no}{sp}
        \PYG{c+c1}{@}
        \PYG{c+c1}{@ routine called with r0 = irq number, r1 = struct pt\PYGZus{}regs *}
        \PYG{c+c1}{@}
        \PYG{n+nf}{badrne}  \PYG{n+no}{lr}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{n+no}{b}
        \PYG{n+nf}{bne}     \PYG{n+no}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}grab\PYGZus{}irq}

        \PYG{c+cm}{/*}
\PYG{c+cm}{         * XXX}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * this macro assumes that irqstat (r2) and base (r6) are}
\PYG{c+cm}{         * preserved from get\PYGZus{}irqnr\PYGZus{}and\PYGZus{}base above}
\PYG{c+cm}{         */}
        \PYG{n+nf}{ALT\PYGZus{}SMP}\PYG{p}{(}\PYG{n+no}{test\PYGZus{}for\PYGZus{}ipi} \PYG{n+no}{r0}\PYG{p}{,} \PYG{n+no}{r2}\PYG{p}{,} \PYG{n+no}{r6}\PYG{p}{,} \PYG{n+no}{lr}\PYG{p}{)}
        \PYG{n+nf}{ALT\PYGZus{}UP\PYGZus{}B}\PYG{p}{(}\PYG{l+m+mi}{9997}\PYG{n+no}{f}\PYG{p}{)}
        \PYG{n+nf}{movne}   \PYG{n+no}{r1}\PYG{p}{,} \PYG{n+no}{sp}
        \PYG{n+nf}{badrne}  \PYG{n+no}{lr}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{n+no}{b}
        \PYG{n+nf}{bne}     \PYG{n+no}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}grab\PYGZus{}ipi}
\PYG{n+nl}{9997:}
        \PYG{n+na}{.endm}
\end{sphinxVerbatim}
\end{quote}

其中 \sphinxcode{\sphinxupquote{get\_irqnr\_preamble}} 和  \sphinxcode{\sphinxupquote{get\_irqnr\_and\_base}} 是和机器相关的了，所谓机器相关也就是说和系统中的中断控制器相关了。
get\_irqnr\_preamble是为中断处理做准备，有些平台根本不需要这个步骤，直接定义为空即可。get\_irqnr\_and\_base 有四个参数，
分别是：r0保存了本次解析的irq number，r2是irq状态寄存器的值，r6是irq controller的base address，lr是scratch register.

其中 \sphinxcode{\sphinxupquote{badrne lr,1b}} 将返回地址设定为符号1，也就是说要不断的解析irq状态寄存器的内容，得到IRQ number，直到所有的irq number处理完毕

对于ARM平台而言，我们推荐使用第一种方法，因为从逻辑上讲，中断处理就是需要根据当前的硬件中断系统的状态，转换成一个IRQ number，
然后调用该IRQ number的处理函数即可。通过get\_irqnr\_and\_base这样的宏定义来获取IRQ是旧的ARM SOC系统使用的方法，
它是假设SOC上有一个中断控制器，硬件状态和IRQ number之间的关系非常简单。
但是实际上，ARM平台上的硬件中断系统已经是越来越复杂了，需要引入interrupt controller级联，irq domain等等概念，
因此，使用第一种方法优点更多。


\subsubsection{bcm\_2836\_arm\_irqchip\_handle\_irq}
\label{\detokenize{004-ipipe/ch-003-arm-int:bcm-2836-arm-irqchip-handle-irq}}\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{void}
\PYG{n}{\PYGZus{}\PYGZus{}exception\PYGZus{}irq\PYGZus{}entry} \PYG{n+nf}{bcm2836\PYGZus{}arm\PYGZus{}irqchip\PYGZus{}handle\PYGZus{}irq}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{pt\PYGZus{}regs} \PYG{o}{*}\PYG{n}{regs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{cpu} \PYG{o}{=} \PYG{n}{raw\PYGZus{}smp\PYGZus{}processor\PYGZus{}id}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{u32} \PYG{n}{stat}\PYG{p}{;}

        \PYG{c+cm}{/* read the interrupt stat register */}
        \PYG{n}{stat} \PYG{o}{=} \PYG{n}{readl\PYGZus{}relaxed}\PYG{p}{(}\PYG{n}{intc}\PYG{p}{.}\PYG{n}{base} \PYG{o}{+} \PYG{n}{LOCAL\PYGZus{}IRQ\PYGZus{}PENDING0} \PYG{o}{+} \PYG{l+m+mi}{4} \PYG{o}{*} \PYG{n}{cpu}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{stat} \PYG{o}{\PYGZam{}} \PYG{n}{BIT}\PYG{p}{(}\PYG{n}{LOCAL\PYGZus{}IRQ\PYGZus{}MAILBOX0}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{void} \PYG{n}{\PYGZus{}\PYGZus{}iomem} \PYG{o}{*}\PYG{n}{mailbox0} \PYG{o}{=} \PYG{p}{(}\PYG{n}{intc}\PYG{p}{.}\PYG{n}{base} \PYG{o}{+}
                                          \PYG{n}{LOCAL\PYGZus{}MAILBOX0\PYGZus{}CLR0} \PYG{o}{+} \PYG{l+m+mi}{16} \PYG{o}{*} \PYG{n}{cpu}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{u32} \PYG{n}{mbox\PYGZus{}val} \PYG{o}{=} \PYG{n}{readl}\PYG{p}{(}\PYG{n}{mailbox0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{u32} \PYG{n}{ipi} \PYG{o}{=} \PYG{n}{ffs}\PYG{p}{(}\PYG{n}{mbox\PYGZus{}val}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}

                \PYG{n}{writel}\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ipi}\PYG{p}{,} \PYG{n}{mailbox0}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{ipipe\PYGZus{}handle\PYGZus{}multi\PYGZus{}ipi}\PYG{p}{(}\PYG{n}{ipi}\PYG{p}{,} \PYG{n}{regs}\PYG{p}{)}\PYG{p}{;} \PYG{c+cm}{/* process the ipi */}
        \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{k}{if} \PYG{p}{(}\PYG{n}{stat}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{u32} \PYG{n}{hwirq} \PYG{o}{=} \PYG{n}{ffs}\PYG{p}{(}\PYG{n}{stat}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{p}{;}

                \PYG{n}{ipipe\PYGZus{}handle\PYGZus{}domain\PYGZus{}irq}\PYG{p}{(}\PYG{n}{intc}\PYG{p}{.}\PYG{n}{domain}\PYG{p}{,} \PYG{n}{hwirq}\PYG{p}{,} \PYG{n}{regs}\PYG{p}{)}\PYG{p}{;} \PYG{c+cm}{/* process irq */}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

读取中断状态寄存器，判断是否是核间中断，是核间中断则交给  \sphinxcode{\sphinxupquote{ipipe\_handle\_multi\_ipi{}`{}`进行处理，是io中断则交给 {}`{}`ipipe\_handle\_domain\_irq}} 进行处理


\subsubsection{\_\_ipipe\_grab\_ipi()}
\label{\detokenize{004-ipipe/ch-003-arm-int:ipipe-grab-ipi}}
该函数主要用于核间中断处理.
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{c+cm}{/* hw IRQs off */}

\PYG{k}{static} \PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n+nf}{ipipe\PYGZus{}handle\PYGZus{}multi\PYGZus{}ipi}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{pt\PYGZus{}regs} \PYG{o}{*}\PYG{n}{regs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}grab\PYGZus{}ipi}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{,} \PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{n}{asmlinkage} \PYG{k+kt}{void} \PYG{n}{\PYGZus{}\PYGZus{}exception} \PYG{n+nf}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}grab\PYGZus{}ipi}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{n}{svc}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{pt\PYGZus{}regs} \PYG{o}{*}\PYG{n}{regs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{virq} \PYG{o}{=} \PYG{n}{IPIPE\PYGZus{}IPI\PYGZus{}BASE} \PYG{o}{+} \PYG{n}{svc}\PYG{p}{;}

        \PYG{c+cm}{/*}
\PYG{c+cm}{         * Virtual NMIs ignore the root domain\PYGZsq{}s stall}
\PYG{c+cm}{         * bit. When caught over high priority}
\PYG{c+cm}{         * domains, virtual VMIs are pipelined the}
\PYG{c+cm}{         * usual way as normal interrupts.}
\PYG{c+cm}{         */}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{virq} \PYG{o}{=}\PYG{o}{=} \PYG{n}{IPIPE\PYGZus{}SERVICE\PYGZus{}VNMI} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}root\PYGZus{}p}\PYG{p}{)}
                \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}vnmi}\PYG{p}{(}\PYG{n}{IPIPE\PYGZus{}SERVICE\PYGZus{}VNMI}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else}
                \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}dispatch\PYGZus{}irq}\PYG{p}{(}\PYG{n}{virq}\PYG{p}{,} \PYG{n}{IPIPE\PYGZus{}IRQF\PYGZus{}NOACK}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}exit\PYGZus{}irq}\PYG{p}{(}\PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}


\subsubsection{\_\_ipipe\_grab\_irq()}
\label{\detokenize{004-ipipe/ch-003-arm-int:ipipe-grab-irq}}
该函数主要用于IO中断处理
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kr}{inline} \PYG{k+kt}{void} \PYG{n+nf}{ipipe\PYGZus{}handle\PYGZus{}multi\PYGZus{}irq}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{pt\PYGZus{}regs} \PYG{o}{*}\PYG{n}{regs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}grab\PYGZus{}irq}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{,} \PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{k}{static} \PYG{k+kr}{inline}
\PYG{k+kt}{int} \PYG{n+nf}{ipipe\PYGZus{}handle\PYGZus{}domain\PYGZus{}irq}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{irq\PYGZus{}domain} \PYG{o}{*}\PYG{n}{domain}\PYG{p}{,}
                            \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{hwirq}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{pt\PYGZus{}regs} \PYG{o}{*}\PYG{n}{regs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{;}
        \PYG{c+cm}{/* dwj find map irq number from irq domain */}
        \PYG{n}{irq} \PYG{o}{=} \PYG{n}{irq\PYGZus{}find\PYGZus{}mapping}\PYG{p}{(}\PYG{n}{domain}\PYG{p}{,} \PYG{n}{hwirq}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{ipipe\PYGZus{}handle\PYGZus{}multi\PYGZus{}irq}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{,} \PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* hw irqs off */}
\PYG{n}{asmlinkage} \PYG{k+kt}{void} \PYG{n}{\PYGZus{}\PYGZus{}exception} \PYG{n+nf}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}grab\PYGZus{}irq}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k}{struct} \PYG{n}{pt\PYGZus{}regs} \PYG{o}{*}\PYG{n}{regs}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}percpu\PYGZus{}data} \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}raw\PYGZus{}cpu\PYGZus{}ptr}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{ipipe\PYGZus{}percpu}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{ipipe\PYGZus{}trace\PYGZus{}irq\PYGZus{}entry}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hrtimer\PYGZus{}irq} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{copy\PYGZus{}regs}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{irq} \PYG{o}{=}\PYG{o}{=} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{hrtimer\PYGZus{}irq}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{c+cm}{/*}
\PYG{c+cm}{                 * Given our deferred dispatching model for regular IRQs, we}
\PYG{c+cm}{                 * only record CPU regs for the last timer interrupt, so that}
\PYG{c+cm}{                 * the timer handler charges CPU times properly. It is assumed}
\PYG{c+cm}{                 * that other interrupt handlers don\PYGZsq{}t actually care for such}
\PYG{c+cm}{                 * information.}
\PYG{c+cm}{                 */}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef CONFIG\PYGZus{}IPIPE\PYGZus{}DEBUG\PYGZus{}INTERNAL}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}mach\PYGZus{}hrtimer\PYGZus{}debug}\PYG{p}{)}
                        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}mach\PYGZus{}hrtimer\PYGZus{}debug}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* CONFIG\PYGZus{}IPIPE\PYGZus{}DEBUG\PYGZus{}INTERNAL */}
          \PYG{n+nl}{copy\PYGZus{}regs}\PYG{p}{:}
                \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{tick\PYGZus{}regs}\PYG{p}{.}\PYG{n}{ARM\PYGZus{}cpsr} \PYG{o}{=}
                        \PYG{p}{(}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{curr} \PYG{o}{=}\PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{root}
                         \PYG{o}{?} \PYG{n}{regs}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n+nl}{ARM\PYGZus{}cpsr}
                         \PYG{p}{:} \PYG{n}{regs}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ARM\PYGZus{}cpsr} \PYG{o}{\textbar{}} \PYG{n}{PSR\PYGZus{}I\PYGZus{}BIT}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{tick\PYGZus{}regs}\PYG{p}{.}\PYG{n}{ARM\PYGZus{}pc} \PYG{o}{=} \PYG{n}{regs}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{ARM\PYGZus{}pc}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}dispatch\PYGZus{}irq}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{ipipe\PYGZus{}trace\PYGZus{}irq\PYGZus{}exit}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}exit\PYGZus{}irq}\PYG{p}{(}\PYG{n}{regs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}


\subsubsection{\_\_ipipe\_dispatch\_irq}
\label{\detokenize{004-ipipe/ch-003-arm-int:ipipe-dispatch-irq}}
该函数主要用户IRQ中断的分发,在讨论IRQ中断分发之前，我们先了解一下，中断的触发类型:
\begin{enumerate}
\item {} 
电平触发中断(Level-Triggered Interrupts)，其时序图如下:

\noindent\sphinxincludegraphics{{level-interrupt}.png}

\item {} 
边缘触发中断(Edge-Triggered Interrupts),其时序图如下:

\noindent\sphinxincludegraphics{{edge-interrupt}.png}

\end{enumerate}

粘滞(Sticky)位:中断信号可以是“粘滞”(sticky)的，这便意味着中断线保持有效状态(高电平)，直到它被读取
或者清除为止。在这种情况下，如果中断组件被配置为RISING\_EDGE，那么将执行一次ISR。如果中断组件被配置为LEVEL，
那么ISR将重复被执行。为解决这个问题，需要使用由组件提供的API清除中断源。请查看中断源的组件数据手册。

IRQ中断分发，主要在函数　\sphinxcode{\sphinxupquote{\_\_ipipe\_dispatch\_irq()}} 中完成，其主要由3个分支组成:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}dispatch\PYGZus{}irq}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{flags}\PYG{p}{)} \PYG{c+cm}{/* hw interrupts off */}
\PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}domain} \PYG{o}{*}\PYG{n}{ipd}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{irq\PYGZus{}desc} \PYG{o}{*}\PYG{n}{desc}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{control}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{chained\PYGZus{}irq}\PYG{p}{;}

        \PYG{c+cm}{/*}
\PYG{c+cm}{         * Survival kit when reading this code:}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * \PYGZhy{} we have two main situations, leading to three cases for}
\PYG{c+cm}{         *   handling interrupts:}
\PYG{c+cm}{         *}
\PYG{c+cm}{         *   a) the root domain is alone, no registered head domain}
\PYG{c+cm}{         *      =\PYGZgt{} all interrupts go through the interrupt log}
\PYG{c+cm}{         *   b) a head domain is registered}
\PYG{c+cm}{         *      =\PYGZgt{} head domain IRQs go through the fast dispatcher}
\PYG{c+cm}{         *      =\PYGZgt{} root domain IRQs go through the interrupt log}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * \PYGZhy{} when no head domain is registered, ipipe\PYGZus{}head\PYGZus{}domain ==}
\PYG{c+cm}{         *   ipipe\PYGZus{}root\PYGZus{}domain == \PYGZam{}ipipe\PYGZus{}root.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * \PYGZhy{} the caller tells us whether we should acknowledge this}
\PYG{c+cm}{         *   IRQ. Even virtual IRQs may require acknowledge on some}
\PYG{c+cm}{         *   platforms (e.g. arm/SMP).}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * \PYGZhy{} the caller tells us whether we may try to run the IRQ log}
\PYG{c+cm}{         *   syncer. Typically, demuxed IRQs won\PYGZsq{}t be synced}
\PYG{c+cm}{         *   immediately.}
\PYG{c+cm}{         *}
\PYG{c+cm}{         * \PYGZhy{} multiplex IRQs most likely have a valid acknowledge}
\PYG{c+cm}{         *   handler and we may not be called with IPIPE\PYGZus{}IRQF\PYGZus{}NOACK}
\PYG{c+cm}{         *   for them. The ack handler for the multiplex IRQ actually}
\PYG{c+cm}{         *   decodes the demuxed interrupts.}
\PYG{c+cm}{         */}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifdef CONFIG\PYGZus{}IPIPE\PYGZus{}DEBUG}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{irq} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{IPIPE\PYGZus{}NR\PYGZus{}IRQS}\PYG{p}{)} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
            \PYG{p}{(}\PYG{n}{irq} \PYG{o}{\PYGZlt{}} \PYG{n}{IPIPE\PYGZus{}NR\PYGZus{}ROOT\PYGZus{}IRQS} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{n}{irq\PYGZus{}to\PYGZus{}desc}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{pr\PYGZus{}err}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{I\PYGZhy{}pipe: spurious interrupt \PYGZpc{}u}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
        \PYG{c+cm}{/*}
\PYG{c+cm}{         * CAUTION: on some archs, virtual IRQs may have acknowledge}
\PYG{c+cm}{         * handlers. Multiplex IRQs should have one too.}
\PYG{c+cm}{         */}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{irq} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{IPIPE\PYGZus{}NR\PYGZus{}ROOT\PYGZus{}IRQS}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{desc} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
                \PYG{n}{chained\PYGZus{}irq} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                \PYG{n}{desc} \PYG{o}{=} \PYG{n}{irq\PYGZus{}to\PYGZus{}desc}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
                \PYG{n}{chained\PYGZus{}irq} \PYG{o}{=} \PYG{n}{desc} \PYG{o}{?} \PYG{n}{ipipe\PYGZus{}chained\PYGZus{}irq\PYGZus{}p}\PYG{p}{(}\PYG{n}{desc}\PYG{p}{)} \PYG{o}{:} \PYG{l+m+mi}{0}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{IPIPE\PYGZus{}IRQF\PYGZus{}NOACK}\PYG{p}{)}
                \PYG{n}{IPIPE\PYGZus{}WARN\PYGZus{}ONCE}\PYG{p}{(}\PYG{n}{chained\PYGZus{}irq}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{else} \PYG{p}{\PYGZob{}}
                \PYG{n}{ipd} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}head\PYGZus{}domain}\PYG{p}{;}
                \PYG{n}{control} \PYG{o}{=} \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{control}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{control} \PYG{o}{\PYGZam{}} \PYG{n}{IPIPE\PYGZus{}HANDLE\PYGZus{}MASK}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{n}{ipd} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}root\PYGZus{}domain}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{ackfn}\PYG{p}{)}
                        \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{ackfn}\PYG{p}{(}\PYG{n}{desc}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{chained\PYGZus{}irq}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{IPIPE\PYGZus{}IRQF\PYGZus{}NOSYNC}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{)}
                                \PYG{c+cm}{/* Run demuxed IRQ handlers. */}
                                \PYG{k}{goto} \PYG{n}{sync}\PYG{p}{;}
                        \PYG{k}{return}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+cm}{/*}
\PYG{c+cm}{         * Sticky interrupts must be handled early and separately, so}
\PYG{c+cm}{         * that we always process them on the current domain.}
\PYG{c+cm}{         */}
        \PYG{n}{ipd} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}current\PYGZus{}domain}\PYG{p}{;}
        \PYG{n}{control} \PYG{o}{=} \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{control}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{control} \PYG{o}{\PYGZam{}} \PYG{n}{IPIPE\PYGZus{}STICKY\PYGZus{}MASK}\PYG{p}{)}
                \PYG{k}{goto} \PYG{n}{log}\PYG{p}{;}

        \PYG{c+cm}{/*}
\PYG{c+cm}{         * In case we have no registered head domain}
\PYG{c+cm}{         * (i.e. ipipe\PYGZus{}head\PYGZus{}domain == \PYGZam{}ipipe\PYGZus{}root), we always go}
\PYG{c+cm}{         * through the interrupt log, and leave the dispatching work}
\PYG{c+cm}{         * ultimately to \PYGZus{}\PYGZus{}ipipe\PYGZus{}sync\PYGZus{}pipeline().}
\PYG{c+cm}{         */}
        \PYG{n}{ipd} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}head\PYGZus{}domain}\PYG{p}{;}
        \PYG{n}{control} \PYG{o}{=} \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{control}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipd} \PYG{o}{=}\PYG{o}{=} \PYG{n}{ipipe\PYGZus{}root\PYGZus{}domain}\PYG{p}{)}
                \PYG{c+cm}{/*}
\PYG{c+cm}{                 * The root domain must handle all interrupts, so}
\PYG{c+cm}{                 * testing the HANDLE bit would be pointless.}
\PYG{c+cm}{                 */}
                \PYG{k}{goto} \PYG{n}{log}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{control} \PYG{o}{\PYGZam{}} \PYG{n}{IPIPE\PYGZus{}HANDLE\PYGZus{}MASK}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{IPIPE\PYGZus{}IRQF\PYGZus{}NOSYNC}\PYG{p}{)}\PYG{p}{)}
                        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}set\PYGZus{}irq\PYGZus{}pending}\PYG{p}{(}\PYG{n}{ipd}\PYG{p}{,} \PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{else}
                        \PYG{n}{dispatch\PYGZus{}irq\PYGZus{}head}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{ipd} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}root\PYGZus{}domain}\PYG{p}{;}
\PYG{n+nl}{log}\PYG{p}{:}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}set\PYGZus{}irq\PYGZus{}pending}\PYG{p}{(}\PYG{n}{ipd}\PYG{p}{,} \PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{IPIPE\PYGZus{}IRQF\PYGZus{}NOSYNC}\PYG{p}{)}
                \PYG{k}{return}\PYG{p}{;}

        \PYG{c+cm}{/*}
\PYG{c+cm}{         * Optimize if we preempted a registered high priority head}
\PYG{c+cm}{         * domain: we don\PYGZsq{}t need to synchronize the pipeline unless}
\PYG{c+cm}{         * there is a pending interrupt for it.}
\PYG{c+cm}{         */}
        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}root\PYGZus{}p} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}
            \PYG{o}{!}\PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ipending\PYGZus{}p}\PYG{p}{(}\PYG{n}{ipipe\PYGZus{}this\PYGZus{}cpu\PYGZus{}head\PYGZus{}context}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{return}\PYG{p}{;}
\PYG{n+nl}{sync}\PYG{p}{:}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}sync\PYGZus{}pipeline}\PYG{p}{(}\PYG{n}{ipipe\PYGZus{}head\PYGZus{}domain}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\item {} 
在没有注册head domain的情况,只有root domain (Condition 1)

\item {} \begin{description}
\item[{在注册了head domain的情况下:}] \leavevmode\begin{itemize}
\item {} 
head domain IRQs go through the fast dispatcher (Condition 2)

\item {} 
root domain IRQs go through the interrupt log (Condition 3)

\end{itemize}

\end{description}

\end{enumerate}

对于情况1，则是没有xenomai的情况，也就是只打了ipipe补丁的情况，这种情况直接调用驱动注册的irq handler即可:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}dispatch\PYGZus{}irq}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{flags}\PYG{p}{)} \PYG{c+cm}{/* hw interrupts off */}
\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//\PYGZus{}\PYGZus{}ipipe\PYGZus{}set\PYGZus{}irq\PYGZus{}pending(ipipe\PYGZus{}root\PYGZus{}domain, irq);}
        \PYG{c+c1}{//\PYGZus{}\PYGZus{}ipipe\PYGZus{}sync\PYGZus{}pipeline(ipipe\PYGZus{}root\PYGZus{}domain);}
        \PYG{k}{for} \PYG{p}{(}\PYG{p}{;}\PYG{p}{;}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{irq} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}next\PYGZus{}irq}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{irq} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{k}{break}\PYG{p}{;}
                \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{handler}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{,} \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{cookie}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

对于情况2,注册了head domain,使用 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:rtdm-irq-request}]{\sphinxcrossref{rtdm\_irq\_request()}}} 注册的irq都设置 IPIPE\_HANDLE\_MASK,表示由IPIPE来处理该irq中断.
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}dispatch\PYGZus{}irq}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{flags}\PYG{p}{)} \PYG{c+cm}{/* hw interrupts off */}
\PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}domain} \PYG{o}{*}\PYG{n}{ipd}\PYG{p}{;}
        \PYG{n}{ipd} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}head\PYGZus{}domain}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{ackfn}\PYG{p}{)}
                \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{ackfn}\PYG{p}{(}\PYG{n}{desc}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{dispatch\PYGZus{}irq\PYGZus{}head}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:dispatch-irq-head}]{\sphinxcrossref{dispatch\_irq\_head}}}

对于情况3,注册了head domain，但是该中断是由request\_irq注册的，即该中断属于root\_domain,则此时和情况1相识。
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}dispatch\PYGZus{}irq}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{flags}\PYG{p}{)} \PYG{c+cm}{/* hw interrupts off */}
\PYG{p}{\PYGZob{}}
        \PYG{c+c1}{//\PYGZus{}\PYGZus{}ipipe\PYGZus{}set\PYGZus{}irq\PYGZus{}pending(ipipe\PYGZus{}root\PYGZus{}domain, irq);}
        \PYG{c+c1}{//\PYGZus{}\PYGZus{}ipipe\PYGZus{}sync\PYGZus{}pipeline(ipipe\PYGZus{}root\PYGZus{}domain);}
        \PYG{k}{for} \PYG{p}{(}\PYG{p}{;}\PYG{p}{;}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{irq} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}next\PYGZus{}irq}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{irq} \PYG{o}{\PYGZlt{}} \PYG{l+m+mi}{0}\PYG{p}{)}
                        \PYG{k}{break}\PYG{p}{;}
                \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{handler}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{,} \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{cookie}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}


\subsubsection{dispatch\_irq\_head}
\label{\detokenize{004-ipipe/ch-003-arm-int:dispatch-irq-head}}\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{static} \PYG{k+kt}{void} \PYG{n+nf}{dispatch\PYGZus{}irq\PYGZus{}head}\PYG{p}{(}\PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{)} \PYG{c+cm}{/* hw interrupts off */}
\PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}percpu\PYGZus{}domain\PYGZus{}data} \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}this\PYGZus{}cpu\PYGZus{}head\PYGZus{}context}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{o}{*}\PYG{n}{old}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}domain} \PYG{o}{*}\PYG{n}{head} \PYG{o}{=} \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{domain}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{unlikely}\PYG{p}{(}\PYG{n}{test\PYGZus{}bit}\PYG{p}{(}\PYG{n}{IPIPE\PYGZus{}STALL\PYGZus{}FLAG}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{status}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}set\PYGZus{}irq\PYGZus{}pending}\PYG{p}{(}\PYG{n}{head}\PYG{p}{,} \PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{return}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+cm}{/* Switch to the head domain if not current. */}
        \PYG{n}{old} \PYG{o}{=} \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}current\PYGZus{}context}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{old} \PYG{o}{!}\PYG{o}{=} \PYG{n}{p}\PYG{p}{)}
                \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}set\PYGZus{}current\PYGZus{}context}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqall}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
        \PYG{n}{\PYGZus{}\PYGZus{}set\PYGZus{}bit}\PYG{p}{(}\PYG{n}{IPIPE\PYGZus{}STALL\PYGZus{}FLAG}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{status}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{barrier}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{handler}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{,} \PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{cookie}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}run\PYGZus{}irqtail}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{hard\PYGZus{}local\PYGZus{}irq\PYGZus{}disable}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{p} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}this\PYGZus{}cpu\PYGZus{}head\PYGZus{}context}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{\PYGZus{}\PYGZus{}clear\PYGZus{}bit}\PYG{p}{(}\PYG{n}{IPIPE\PYGZus{}STALL\PYGZus{}FLAG}\PYG{p}{,} \PYG{o}{\PYGZam{}}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{status}\PYG{p}{)}\PYG{p}{;}

        \PYG{c+cm}{/* Are we still running in the head domain? */}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{likely}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}current\PYGZus{}context} \PYG{o}{=}\PYG{o}{=} \PYG{n}{p}\PYG{p}{)}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{c+cm}{/* Did we enter this code over the head domain? */}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{old}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{domain} \PYG{o}{=}\PYG{o}{=} \PYG{n}{head}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{c+cm}{/* Yes, do immediate synchronization. */}
                        \PYG{k}{if} \PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}ipending\PYGZus{}p}\PYG{p}{(}\PYG{n}{p}\PYG{p}{)}\PYG{p}{)}
                                \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}sync\PYGZus{}stage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                        \PYG{k}{return}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
                \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}set\PYGZus{}current\PYGZus{}context}\PYG{p}{(}\PYG{n}{ipipe\PYGZus{}this\PYGZus{}cpu\PYGZus{}root\PYGZus{}context}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{c+cm}{/*}
\PYG{c+cm}{         * We must be running over the root domain, synchronize}
\PYG{c+cm}{         * the pipeline for high priority IRQs (slow path).}
\PYG{c+cm}{         */}
        \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}sync\PYGZus{}pipeline}\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}


\subsubsection{rtdm\_irq\_request()}
\label{\detokenize{004-ipipe/ch-003-arm-int:rtdm-irq-request}}\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* see kernel/xenomai/rtdm/drvlib.c */}

\PYG{k+kt}{int} \PYG{n+nf}{rtdm\PYGZus{}irq\PYGZus{}request}\PYG{p}{(}\PYG{n}{rtdm\PYGZus{}irq\PYGZus{}t} \PYG{o}{*}\PYG{n}{irq\PYGZus{}handle}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq\PYGZus{}no}\PYG{p}{,}
                     \PYG{n}{rtdm\PYGZus{}irq\PYGZus{}handler\PYGZus{}t} \PYG{n}{handler}\PYG{p}{,} \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{flags}\PYG{p}{,}
                     \PYG{k}{const} \PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{device\PYGZus{}name}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{arg}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{err}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{XENO\PYGZus{}ASSERT}\PYG{p}{(}\PYG{n}{COBALT}\PYG{p}{,} \PYG{n}{xnsched\PYGZus{}root\PYGZus{}p}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{EPERM}\PYG{p}{;}

        \PYG{n}{err} \PYG{o}{=} \PYG{n}{xnintr\PYGZus{}init}\PYG{p}{(}\PYG{n}{irq\PYGZus{}handle}\PYG{p}{,} \PYG{n}{device\PYGZus{}name}\PYG{p}{,} \PYG{n}{irq\PYGZus{}no}\PYG{p}{,} \PYG{n}{handler}\PYG{p}{,} \PYG{n+nb}{NULL}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{err}\PYG{p}{)}
                \PYG{k}{return} \PYG{n}{err}\PYG{p}{;}

        \PYG{n}{err} \PYG{o}{=} \PYG{n}{xnintr\PYGZus{}attach}\PYG{p}{(}\PYG{n}{irq\PYGZus{}handle}\PYG{p}{,} \PYG{n}{arg}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{err}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{xnintr\PYGZus{}destroy}\PYG{p}{(}\PYG{n}{irq\PYGZus{}handle}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{return} \PYG{n}{err}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{xnintr\PYGZus{}enable}\PYG{p}{(}\PYG{n}{irq\PYGZus{}handle}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}


\PYG{c+cm}{/* see ./kernel/xenomai/intr.c */}
\PYG{k}{static} \PYG{k+kr}{inline} \PYG{k+kt}{int} \PYG{n+nf}{xnintr\PYGZus{}irq\PYGZus{}attach}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{xnintr} \PYG{o}{*}\PYG{n}{intr}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{xnintr\PYGZus{}vector} \PYG{o}{*}\PYG{n}{vec} \PYG{o}{=} \PYG{n}{vectors} \PYG{o}{+} \PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irq}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{xnintr} \PYG{o}{*}\PYG{n}{prev}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{vec}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{handlers}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{ret}\PYG{p}{;}

        \PYG{n}{prev} \PYG{o}{=} \PYG{o}{*}\PYG{n}{p}\PYG{p}{;}
        \PYG{k}{if} \PYG{p}{(}\PYG{n}{prev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{c+cm}{/* Check on whether the shared mode is allowed. */}
                \PYG{k}{if} \PYG{p}{(}\PYG{p}{(}\PYG{n}{prev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{XN\PYGZus{}IRQTYPE\PYGZus{}SHARED}\PYG{p}{)} \PYG{o}{=}\PYG{o}{=} \PYG{l+m+mi}{0} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
                    \PYG{p}{(}\PYG{n}{prev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{iack} \PYG{o}{!}\PYG{o}{=} \PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{iack}\PYG{p}{)}
                    \PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{prev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{XN\PYGZus{}IRQTYPE\PYGZus{}EDGE}\PYG{p}{)} \PYG{o}{!}\PYG{o}{=}
                        \PYG{p}{(}\PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{XN\PYGZus{}IRQTYPE\PYGZus{}EDGE}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                        \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{EBUSY}\PYG{p}{;}

                \PYG{c+cm}{/*}
\PYG{c+cm}{                 * Get a position at the end of the list to insert the}
\PYG{c+cm}{                 * new element.}
\PYG{c+cm}{                 */}
                \PYG{k}{while} \PYG{p}{(}\PYG{n}{prev}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{n}{p} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{prev}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
                        \PYG{n}{prev} \PYG{o}{=} \PYG{o}{*}\PYG{n}{p}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}} \PYG{k}{else} \PYG{p}{\PYGZob{}}
                \PYG{c+cm}{/* Initialize the corresponding interrupt channel */}
                \PYG{k+kt}{void} \PYG{p}{(}\PYG{o}{*}\PYG{n}{handler}\PYG{p}{)} \PYG{p}{(}\PYG{k+kt}{unsigned}\PYG{p}{,} \PYG{k+kt}{void} \PYG{o}{*}\PYG{p}{)} \PYG{o}{=} \PYG{n}{xnintr\PYGZus{}irq\PYGZus{}handler}\PYG{p}{;}

                \PYG{k}{if} \PYG{p}{(}\PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{XN\PYGZus{}IRQTYPE\PYGZus{}SHARED}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                        \PYG{k}{if} \PYG{p}{(}\PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{flags} \PYG{o}{\PYGZam{}} \PYG{n}{XN\PYGZus{}IRQTYPE\PYGZus{}EDGE}\PYG{p}{)}
                                \PYG{n}{handler} \PYG{o}{=} \PYG{n}{xnintr\PYGZus{}edge\PYGZus{}vec\PYGZus{}handler}\PYG{p}{;}
                        \PYG{k}{else}
                                \PYG{n}{handler} \PYG{o}{=} \PYG{n}{xnintr\PYGZus{}vec\PYGZus{}handler}\PYG{p}{;}

                \PYG{p}{\PYGZcb{}}
                \PYG{n}{vec}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{unhandled} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

                \PYG{n}{ret} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}request\PYGZus{}irq}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{xnsched\PYGZus{}realtime\PYGZus{}domain}\PYG{p}{,}
                                        \PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irq}\PYG{p}{,} \PYG{n}{handler}\PYG{p}{,} \PYG{n}{intr}\PYG{p}{,}
                                        \PYG{p}{(}\PYG{n}{ipipe\PYGZus{}irq\PYGZus{}ackfn\PYGZus{}t}\PYG{p}{)}\PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{iack}\PYG{p}{)}\PYG{p}{;}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{ret}\PYG{p}{)}
                        \PYG{k}{return} \PYG{n}{ret}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{n}{intr}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}
        \PYG{c+cm}{/*}
\PYG{c+cm}{         * Add the given interrupt object. No need to synchronise with}
\PYG{c+cm}{         * the IRQ handler, we are only extending the chain.}
\PYG{c+cm}{         */}
        \PYG{o}{*}\PYG{n}{p} \PYG{o}{=} \PYG{n}{intr}\PYG{p}{;}

        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/* see ./kernel/ipipe/core.c */}
\PYG{k+kt}{int} \PYG{n+nf}{ipipe\PYGZus{}request\PYGZus{}irq}\PYG{p}{(}\PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}domain} \PYG{o}{*}\PYG{n}{ipd}\PYG{p}{,}
      \PYG{k+kt}{unsigned} \PYG{k+kt}{int} \PYG{n}{irq}\PYG{p}{,}
      \PYG{n}{ipipe\PYGZus{}irq\PYGZus{}handler\PYGZus{}t} \PYG{n}{handler}\PYG{p}{,}
      \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{cookie}\PYG{p}{,}
      \PYG{n}{ipipe\PYGZus{}irq\PYGZus{}ackfn\PYGZus{}t} \PYG{n}{ackfn}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{flags}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{ret} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef CONFIG\PYGZus{}IPIPE\PYGZus{}LEGACY}
        \PYG{n}{ipipe\PYGZus{}root\PYGZus{}only}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif }\PYG{c+cm}{/* CONFIG\PYGZus{}IPIPE\PYGZus{}LEGACY */}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{handler} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}
            \PYG{p}{(}\PYG{n}{irq} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{IPIPE\PYGZus{}NR\PYGZus{}XIRQS} \PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}} \PYG{o}{!}\PYG{n}{ipipe\PYGZus{}virtual\PYGZus{}irq\PYGZus{}p}\PYG{p}{(}\PYG{n}{irq}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{n}{EINVAL}\PYG{p}{;}

        \PYG{n}{raw\PYGZus{}spin\PYGZus{}lock\PYGZus{}irqsave}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}lock}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{handler}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{n}{ret} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{EBUSY}\PYG{p}{;}
                \PYG{k}{goto} \PYG{n}{out}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{ackfn} \PYG{o}{=}\PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{)}
                \PYG{n}{ackfn} \PYG{o}{=} \PYG{n}{ipipe\PYGZus{}root\PYGZus{}domain}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{ackfn}\PYG{p}{;}

        \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{handler} \PYG{o}{=} \PYG{n}{handler}\PYG{p}{;}
        \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{cookie} \PYG{o}{=} \PYG{n}{cookie}\PYG{p}{;}
        \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{ackfn} \PYG{o}{=} \PYG{n}{ackfn}\PYG{p}{;}
        \PYG{n}{ipd}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{irqs}\PYG{p}{[}\PYG{n}{irq}\PYG{p}{]}\PYG{p}{.}\PYG{n}{control} \PYG{o}{=} \PYG{n}{IPIPE\PYGZus{}HANDLE\PYGZus{}MASK}\PYG{p}{;}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{irq} \PYG{o}{\PYGZlt{}} \PYG{n}{IPIPE\PYGZus{}NR\PYGZus{}ROOT\PYGZus{}IRQS}\PYG{p}{)}
                \PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}enable\PYGZus{}irqdesc}\PYG{p}{(}\PYG{n}{ipd}\PYG{p}{,} \PYG{n}{irq}\PYG{p}{)}\PYG{p}{;}
\PYG{n+nl}{out}\PYG{p}{:}
        \PYG{n}{raw\PYGZus{}spin\PYGZus{}unlock\PYGZus{}irqrestore}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}lock}\PYG{p}{,} \PYG{n}{flags}\PYG{p}{)}\PYG{p}{;}

        \PYG{k}{return} \PYG{n}{ret}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{EXPORT\PYGZus{}SYMBOL\PYGZus{}GPL}\PYG{p}{(}\PYG{n}{ipipe\PYGZus{}request\PYGZus{}irq}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}


\subsection{内核态IRQ}
\label{\detokenize{004-ipipe/ch-003-arm-int:id15}}

\section{快速中断(FIQ)}
\label{\detokenize{004-ipipe/ch-003-arm-int:fiq}}

\section{irq domain}
\label{\detokenize{004-ipipe/ch-003-arm-int:irq-domain}}
在linux kernel中，我们使用下面两个ID来标识一个来自外设的中断：

1. IRQ number。CPU需要为每一个外设中断编号，我们称之IRQ Number。
这个IRQ number是一个虚拟的interrupt ID，和硬件无关，仅仅是被CPU用来标识一个外设中断。

2. HW interrupt ID。对于中断控制器而言，它收集了多个外设的interrupt request line并向上传递，因此，中断控制器需要对外设中断进行编码。
中断控制器用HW interrupt ID来标识外设的中断。在中断控制器级联的情况下，仅仅用HW interrupt ID已经不能唯一标识一个外设中断，
还需要知道该HW interrupt ID所属的中断控制器(HW interrupt ID在不同的中断控制器上是会重复编码的）.

这样，CPU和中断控制器在标识中断上就有了一些不同的概念，但是，对于驱动工程师而言，我们和CPU视角是一样的，
我们只希望得到一个IRQ number，而不关系具体是那个中断控制器上的那个HW interrupt ID。
这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。
因此，内核中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制.


\subsection{历史}
\label{\detokenize{004-ipipe/ch-003-arm-int:id16}}
关于HW interrupt ID映射到IRQ number上这事，在过去系统只有一个中断的时候还是很简单的，
中断控制器上实际的HW interrupt line的编号可以直接变成IRQ number。
例如我们大家都熟悉的SOC内嵌的中断控制器，这种controller多半有中断状态寄存器，
这个寄存器可能有64个bit（也可能更多），每个bit就是一个IRQ number，可以直接进行映射。
这时候，GPIO的中断在中断控制器的状态寄存器中只有一个bit，因此所有的GPIO中断只有一个IRQ number，
在该通用GPIO中断的irq handler中进行duplex，将各个具体的GPIO中断映射到其相应的IRQ number上。

随着内核的发展，将中断控制器抽象成irqchip这个概念越来越流行，甚至GPIO controller也可以被看出一个中断控制器芯片，
这样，系统中至少有两个中断控制器了，一个传统意义的中断控制器，一个是GPIO controller类型的中断控制器。
随着系统复杂度加大，外设中断数据增加，实际上系统可能需要多个中断控制器进行级联，面对这样的趋势，内核工程师如何应对？
答案就是irq domain这个概念。

我们听说过很多的domain，power domain，clock domain等等，所谓domain，就是领域，范围的意思，也就是说，任何的定义超出这个范围就没有意义了。
系统中所有的中断会形成树状结构，对于每个中断都可以连接若干个外设的中断请求（我们称之interrupt source），中断控制器会对连接其上的interrupt source
(根据其在中断控制器中的物理特性)进行编号(也就是HW interrupt ID了)。但这个编号仅仅限制在本中断控制器范围内。

具体如何进行映射是中端自己的事情，不过，有软件架构思想的工程师更愿意对形形色色的中断控制进行抽象，对如何从HW interrupt ID到IRQ number
映射关系上进行进一步的抽象。因此，中断处理模块中有一个irq domain的子模块，该模块将这种映射关系分成了三类：
\begin{itemize}
\item {} 
线性映射

\item {} 
基数树映射(Radix Tree Map)

\item {} 
没有映射(No Map)

\end{itemize}


\subsection{初始化}
\label{\detokenize{004-ipipe/ch-003-arm-int:id17}}
其总体流程如下:

\noindent\sphinxincludegraphics{{int-subsystem}.png}


\section{i-pipe domain}
\label{\detokenize{004-ipipe/ch-003-arm-int:i-pipe-domain}}
在xenomai双内核中有两i-pipe domain分别是root domain %
\begin{footnote}[3]\sphinxAtStartFootnote
该domain即linux domain,也被称为secondary domain
%
\end{footnote} 和head domain %
\begin{footnote}[4]\sphinxAtStartFootnote
该domain 即xenomai domain,也被称为master domain
%
\end{footnote}，
两个domain的优先级不同,head domain最高，其次是root domain.在内核实现中使用类 struct ipipe\_domain对两个domain进行抽象．

在ipipe初始化时，只是初始化了root domain(参见 {\hyperref[\detokenize{004-ipipe/ch-003-arm-int:ipipe-init-early}]{\sphinxcrossref{\_\_ipipe\_init\_early()}}} ),而head domain在xenomai中进行初始化(参见 \DUrole{xref,std,std-ref}{mach\_setup} )

其初始化完成后，如下图：

\noindent\sphinxincludegraphics{{ipipe-domain}.png}

其中,每个cpu绑定了一个cpu变量ipipe\_percpu,该变量为struct ipipe\_percpu\_data的结构体:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}percpu\PYGZus{}data} \PYG{p}{\PYGZob{}}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}percpu\PYGZus{}domain\PYGZus{}data} \PYG{n}{root}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}percpu\PYGZus{}domain\PYGZus{}data} \PYG{n}{head}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}percpu\PYGZus{}domain\PYGZus{}data} \PYG{o}{*}\PYG{n}{curr}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{pt\PYGZus{}regs} \PYG{n}{tick\PYGZus{}regs}\PYG{p}{;}
        \PYG{k+kt}{int} \PYG{n}{hrtimer\PYGZus{}irq}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{task\PYGZus{}struct} \PYG{o}{*}\PYG{n}{task\PYGZus{}hijacked}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{task\PYGZus{}struct} \PYG{o}{*}\PYG{n}{rqlock\PYGZus{}owner}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}vm\PYGZus{}notifier} \PYG{o}{*}\PYG{n}{vm\PYGZus{}notifier}\PYG{p}{;}
        \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{nmi\PYGZus{}state}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{mm\PYGZus{}struct} \PYG{o}{*}\PYG{n}{active\PYGZus{}mm}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
root:用于保存root domain的信息

\item {} 
head:用于保存head domain的信息

\item {} 
curr:该指针指向当前的ipipe domain

\end{itemize}

ipipe\_root和xnsched\_realtime\_domain为struct ipipe\_domain类型的结构体，即root domain和head domain:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}domain} \PYG{p}{\PYGZob{}}
        \PYG{k+kt}{int} \PYG{n}{context\PYGZus{}offset}\PYG{p}{;}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}irqdesc} \PYG{p}{\PYGZob{}}
                \PYG{k+kt}{unsigned} \PYG{k+kt}{long} \PYG{n}{control}\PYG{p}{;}
                \PYG{n}{ipipe\PYGZus{}irq\PYGZus{}ackfn\PYGZus{}t} \PYG{n}{ackfn}\PYG{p}{;}
                \PYG{c+cm}{/* The irq handler */}
                \PYG{n}{ipipe\PYGZus{}irq\PYGZus{}handler\PYGZus{}t} \PYG{n}{handler}\PYG{p}{;}
                \PYG{k+kt}{void} \PYG{o}{*}\PYG{n}{cookie}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{n}{\PYGZus{}\PYGZus{}\PYGZus{}\PYGZus{}cacheline\PYGZus{}aligned} \PYG{n}{irqs}\PYG{p}{[}\PYG{n}{IPIPE\PYGZus{}NR\PYGZus{}IRQS}\PYG{p}{]}\PYG{p}{;}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{p}{.}\PYG{p}{.}\PYG{p}{.}
        \PYG{k}{struct} \PYG{n}{ipipe\PYGZus{}legacy\PYGZus{}context} \PYG{n}{legacy}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
在初始化ipipe\_root后，irqs{[}0-1023{]}.hander都指向 \sphinxcode{\sphinxupquote{\_\_ipipe\_do\_IRQ}} 用于处理IO中断,而irqs{[}1024-1055{]}都指向 \sphinxcode{\sphinxupquote{\_\_ipipe\_do\_IPI}}
用于处理核间中断. 中断处理函数 \sphinxcode{\sphinxupquote{\_\_ipipe\_do\_IRQ}} 和 \sphinxcode{\sphinxupquote{\_\_ipipe\_do\_IPI}} 都是完成irq中断的分发

\item {} 
control:中断控制位,可能设置的位为 \sphinxcode{\sphinxupquote{IPIPE\_HANDLE\_FLAG}} , \sphinxcode{\sphinxupquote{IPIPE\_STICKY\_FLAG}} , \sphinxcode{\sphinxupquote{IPIPE\_LOCK\_FLAG}}

\item {} 
ackfn:在中断处理中，清除中断标志被称为acknowledgement,由外设驱动注册irq时，填写该回调函数

\item {} 
handler:对应irq的中断处理函数

\end{itemize}


\subsection{\_\_ipipe\_init\_early()}
\label{\detokenize{004-ipipe/ch-003-arm-int:ipipe-init-early}}\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n}{\PYGZus{}\PYGZus{}init} \PYG{n+nf}{\PYGZus{}\PYGZus{}ipipe\PYGZus{}init\PYGZus{}early}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{c+cm}{/* irq number ranges [0.....1024......1055]  1024+32}
\PYG{c+cm}{         * .0\PYGZhy{}1023                               \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IRQ}
\PYG{c+cm}{         * .1024 IPI\PYGZus{}WAKEUP                      \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1025 IPI\PYGZus{}TIMER                       \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1026 IPI\PYGZus{}RESCHEDULE                  \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1027 IPI\PYGZus{}CALL\PYGZus{}FUNC                   \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1028 IPI\PYGZus{}CPU\PYGZus{}STOP                    \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1029 IPI\PYGZus{}IRQ\PYGZus{}WORK                    \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1030 IPI\PYGZus{}COMPLETION                  \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1031 IPI\PYGZus{}CPU\PYGZus{}BACKTRACE               \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}IPI}
\PYG{c+cm}{         * .1032 IPIPE\PYGZus{}CRITICAL\PYGZus{}IPI              \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}critical\PYGZus{}sync}
\PYG{c+cm}{         * .1033 IPIPE\PYGZus{}HRTIMER\PYGZus{}IPI               xnintr\PYGZus{}core\PYGZus{}clock\PYGZus{}handler (not initialized at here)}
\PYG{c+cm}{         * .1034 IPIPE\PYGZus{}RESCHEDULE\PYGZus{}IPI            \PYGZus{}\PYGZus{}xnsched\PYGZus{}run\PYGZus{}handler (not initialized at here)}
\PYG{c+cm}{         * .1035 IPIPE\PYGZus{}SERVICE\PYGZus{}VNM               \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}vnmi}
\PYG{c+cm}{         * .1036 \PYGZus{}\PYGZus{}ipipe\PYGZus{}printk\PYGZus{}virq             \PYGZus{}\PYGZus{}ipipe\PYGZus{}flush\PYGZus{}printk}
\PYG{c+cm}{         * .1037 \PYGZus{}\PYGZus{}ipipe\PYGZus{}work\PYGZus{}virq               \PYGZus{}\PYGZus{}ipipe\PYGZus{}do\PYGZus{}work}
\PYG{c+cm}{         * .1038 cobalt\PYGZus{}pipeline.apc\PYGZus{}virq        apc\PYGZus{}dispatch (at mach\PYGZus{}setup)}
\PYG{c+cm}{         * .1039 cobalt\PYGZus{}pipeline.escalate\PYGZus{}virq   \PYGZus{}\PYGZus{}xnsched\PYGZus{}run\PYGZus{}handler (at mach\PYGZus{}setup)}
\PYG{c+cm}{         */}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}


\subsection{\_\_ipipe\_init()}
\label{\detokenize{004-ipipe/ch-003-arm-int:ipipe-init}}

\subsection{handle\_IRQ()}
\label{\detokenize{004-ipipe/ch-003-arm-int:handle-irq}}

\subsection{handle\_IPI()}
\label{\detokenize{004-ipipe/ch-003-arm-int:handle-ipi}}
\_\_ipipe\_do\_IPI


\section{中断描述符}
\label{\detokenize{004-ipipe/ch-003-arm-int:id22}}
irq number和中断描述符进行关联，在内核开启了 \sphinxcode{\sphinxupquote{CONFIG\_SPARSE\_IRQ}} 选项后所用irq number的中断描述符，都存放在radix tree中，
通过关键字irq number查找返回对应中断描述符．

当发生中断后，首先获取触发中断的HW interupt ID，然后通过irq domain翻译成irq number，然后通过irq number就可以获取对应的中断描述符。
调用中断描述符中的 \sphinxcode{\sphinxupquote{handle\_irq}} 来进行中断处理就OK了.如下图:

\noindent\sphinxincludegraphics{{irq-desc}.png}


\section{frame pointer}
\label{\detokenize{004-ipipe/ch-003-arm-int:frame-pointer}}
关于fp寄存器,我们考虑下面的代码:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{hello\PYGZus{}word}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{a}\PYG{p}{,}\PYG{k+kt}{int} \PYG{n}{b}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{argc}\PYG{p}{,}\PYG{k+kt}{char} \PYG{o}{*}\PYG{n}{argv}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
        \PYG{n}{helloword}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}

添加了 \sphinxcode{\sphinxupquote{-fomit-frame-pointer}} 编译选项后的反汇编代码为:
\begin{quote}
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mh}{00000000} \PYG{p}{\PYGZlt{}}\PYG{n+nf}{hello\PYGZus{}world}\PYG{p}{\PYGZgt{}:}
\PYG{x}{   0:   e24dd008        sub     sp, sp, \PYGZsh{}8}
\PYG{x}{   4:   e58d0004        str     r0, [sp, \PYGZsh{}4]}
\PYG{x}{   8:   e58d1000        str     r1, [sp]}
\PYG{x}{   c:   e3a03000        mov     r3, \PYGZsh{}0}
\PYG{x}{  10:   e1a00003        mov     r0, r3}
\PYG{x}{  14:   e28dd008        add     sp, sp, \PYGZsh{}8}
\PYG{x}{  18:   e12fff1e        bx      lr}

\PYG{l+m+mh}{0000001c} \PYG{p}{\PYGZlt{}}\PYG{n+nf}{main}\PYG{p}{\PYGZgt{}:}
\PYG{x}{  1c:   e52de004        push    \PYGZob{}lr\PYGZcb{}            ; (str lr, [sp, \PYGZsh{}\PYGZhy{}4]!)}
\PYG{x}{  20:   e24dd00c        sub     sp, sp, \PYGZsh{}12}
\PYG{x}{  24:   e58d0004        str     r0, [sp, \PYGZsh{}4]}
\PYG{x}{  28:   e58d1000        str     r1, [sp]}
\PYG{x}{  2c:   e3a01002        mov     r1, \PYGZsh{}2}
\PYG{x}{  30:   e3a00001        mov     r0, \PYGZsh{}1}
\PYG{x}{  34:   ebfffffe        bl      0 \PYGZlt{}hello\PYGZus{}world\PYGZgt{}}
\PYG{x}{  38:   e3a03000        mov     r3, \PYGZsh{}0}
\PYG{x}{  3c:   e1a00003        mov     r0, r3}
\PYG{x}{  40:   e28dd00c        add     sp, sp, \PYGZsh{}12}
\PYG{x}{  44:   e49df004        pop     \PYGZob{}pc\PYGZcb{}            ; (ldr pc, [sp], \PYGZsh{}4)}
\end{sphinxVerbatim}
\end{quote}

没有添加 \sphinxcode{\sphinxupquote{-fomit-frame-pointer}} 编译选项的反汇编代码为:
\begin{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mh}{00000000} \PYG{p}{\PYGZlt{}}\PYG{n+nf}{hello\PYGZus{}world}\PYG{p}{\PYGZgt{}:}
\PYG{x}{   0:   e52db004        push    \PYGZob{}fp\PYGZcb{}            ; (str fp, [sp, \PYGZsh{}\PYGZhy{}4]!)}
\PYG{x}{   4:   e28db000        add     fp, sp, \PYGZsh{}0}
\PYG{x}{   8:   e24dd00c        sub     sp, sp, \PYGZsh{}12}
\PYG{x}{   c:   e50b0008        str     r0, [fp, \PYGZsh{}\PYGZhy{}8]}
\PYG{x}{  10:   e50b100c        str     r1, [fp, \PYGZsh{}\PYGZhy{}12]}
\PYG{x}{  14:   e3a03000        mov     r3, \PYGZsh{}0}
\PYG{x}{  18:   e1a00003        mov     r0, r3}
\PYG{x}{  1c:   e28bd000        add     sp, fp, \PYGZsh{}0}
\PYG{x}{  20:   e49db004        pop     \PYGZob{}fp\PYGZcb{}            ; (ldr fp, [sp], \PYGZsh{}4)}
\PYG{x}{  24:   e12fff1e        bx      lr}

\PYG{l+m+mh}{00000028} \PYG{p}{\PYGZlt{}}\PYG{n+nf}{main}\PYG{p}{\PYGZgt{}:}
\PYG{x}{  28:   e92d4800        push    \PYGZob{}fp, lr\PYGZcb{}}
\PYG{x}{  2c:   e28db004        add     fp, sp, \PYGZsh{}4}
\PYG{x}{  30:   e24dd008        sub     sp, sp, \PYGZsh{}8}
\PYG{x}{  34:   e50b0008        str     r0, [fp, \PYGZsh{}\PYGZhy{}8]}
\PYG{x}{  38:   e50b100c        str     r1, [fp, \PYGZsh{}\PYGZhy{}12]}
\PYG{x}{  3c:   e3a01002        mov     r1, \PYGZsh{}2}
\PYG{x}{  40:   e3a00001        mov     r0, \PYGZsh{}1}
\PYG{x}{  44:   ebfffffe        bl      0 \PYGZlt{}hello\PYGZus{}world\PYGZgt{}}
\PYG{x}{  48:   e3a03000        mov     r3, \PYGZsh{}0}
\PYG{x}{  4c:   e1a00003        mov     r0, r3}
\PYG{x}{  50:   e24bd004        sub     sp, fp, \PYGZsh{}4}
\PYG{x}{  54:   e8bd8800        pop     \PYGZob{}fp, pc\PYGZcb{}}
\end{sphinxVerbatim}
\end{quote}
\end{quote}

我们发现没有添加编译选项 \sphinxcode{\sphinxupquote{-fomit-frame-pointer}} 的反汇编代码做了更多的工作,其堆栈过程如下图:

\noindent\sphinxincludegraphics{{frame-pointer}.png}



\renewcommand{\indexname}{Index}
\printindex
\end{document}